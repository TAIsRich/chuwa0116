## 2 what is selenium(YouTube)?

Selenium is a free (open-source) automated testing framework used to validate web applications across different browsers and platforms. You can use multiple programming languages like Java, C#, Python, etc to create Selenium Test Scripts. Testing done using the Selenium testing tool is usually referred to as Selenium Testing.

## 3 what is cucumber(youtuebe)?

Cucumber is a tool that supports Behaviour-Driven Development (BDD) - a software development process that aims to enhance software quality and reduce maintenance costs.

## 4. what is JMeter(youtube)?

The Apache JMeter is an open-source, purely Java-based software. The software is used to perform performance testing, functional testing, and load testing of web applications. It is used to test load testing functional behavior and measuring performance.

## 5. what is unit-test?

Unit testing is a software testing method by which individual units of source code—sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures—are tested to determine whether they are fit for use.

## 6. What is the lifecircle of Junit?

1. @BeforeClass:
This annotation must be used on public static void no-arg method.
The method is invoked before an instance of this test class is created and any tests are invoked.

This life cycle callback is not related to JVM class loading. JUnit framework calls this method explicitly before calling constructor/other methods.
This method is called only once, whereas, other instance lifecycle methods are called every time before calling each test method.

This annotation is useful for initializing static resources which would, otherwise, be expensive to create during each test invocation.

2. @AfterClass: Similar to @BeforeClass but is called at the very end of all test/other lifecycle methods. It is called only once. Useful for static resource clean up.

3. @Before:
It should be used on public void no-arg instance method.

It is invoked every time before each test method invocation.

Used to setup instance variables/resources which can be used during a test method execution. Useful to avoid code duplication and/or when there are many indirection of method calls starting from the target test method.

4. @After: Similar to @Before but runs after target test method execution. Useful for cleaning up instance resources.

5. @Test: public void methods to perform tests. This is where we perform one or more assertions by using static methods of org.junit.Assert. Assert methods throw org.junit.AssertionError on assertion failure. This exception or any other exception is reported as test failure. If no exceptions are thrown then the test will pass.


## 7. Is @BeforeAll method should be Class level(static)?


@BeforeAll methods must have a void return type, must not be private , and must be static by default. 

## 8. What is Mockito? and what is its limitations?

Mockito is a Java-based framework used for unit testing of Java applications. This mocking framework helps in the development of testable applications. You use Java Reflection API internally to generate mock objects.

1. Mockito cannot mock static methods or final classes: Mockito uses dynamic proxy to create mock objects, which cannot be used to mock static methods or final classes. To work around this limitation, developers can use tools such as PowerMock, which extends Mockito to support mocking of static methods and final classes.

2. Mockito can only mock non-private methods: Mockito can only mock non-private methods, as it uses reflection to create mock objects. This means that private methods cannot be tested using Mockito.

3. Mockito can lead to over-reliance on mocks: While mock objects can be useful for testing complex dependencies, over-reliance on mocks can lead to tests that are not reflective of the behavior of the actual code. Developers should use mocks judiciously and ensure that their tests are still representative of the behavior of the code in the real world.

## 9. What is @Mock and what is @InjectMocks?

The @Mock annotation is used to create mock objects that can be used to replace dependencies in a test class. The @InjectMocks annotation is used to create an instance of a class and inject the mock objects into it, allowing you to test the behavior of the class.

## 10. What is the stubbing?

The stub is an interface that has a minimum count of methods to simulate the actual object. It is an object that has preexisting data and returns a fixed value irrespective of input. Moreover, we mainly use it when we want to avoid a response from the real object.

## 11. what is Mockito ArgumentMatchers

Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. It extends ArgumentMatchers class to access all the matcher functions. Mockito uses equal() as a legacy method for verification and matching of argument values.

## 12. what is Hamcrest Matchers

Hamcrest is a framework for writing matcher objects allowing 'match' rules to be defined declaratively. There are a number of situations where matchers are invaluable, such as UI validation or data filtering, but it is in the area of writing flexible tests that matchers are most commonly used.

## 13. do you know @spy? what is difference between @spy and @Mock?

@Spy - It allows the creation of partially mock objects. In other words, it allows shorthand wrapping of the field instances in a spy object. Like other annotations, @Spy annotation is also available in the org.

Both can be used to mock methods or fields. The difference is that in mock, you are creating a complete mock or fake object while in spy, there is the real object and you just spying or stubbing specific methods of it. When using mock objects, the default behavior of the method when not stub is do nothing.
