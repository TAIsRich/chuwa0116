### 1. Document the microservice architeture and components/tools/dependencies    

Microservice architecture is a software development approach that structures an application as a collection of small, independent services, each focused on a specific business capability. These services communicate with each other through APIs, often over HTTP, and can be developed, deployed, and scaled independently of one another. The following are the key components and tools/dependencies used in a typical microservice architecture:     

1. Service registry: A service registry is a centralized directory that maintains a list of all the microservices in an application along with their location and endpoint information. Examples of popular service registries include Consul, Eureka, and ZooKeeper.     

2. API gateway: An API gateway acts as a single entry point for all client requests and provides a unified interface to the microservices. It can handle routing, load balancing, security, and other cross-cutting concerns. Popular API gateways include NGINX, Kong, and Istio.     

3. Service mesh: A service mesh is a dedicated infrastructure layer for managing service-to-service communication within a microservices application. It provides features such as traffic routing, service discovery, load balancing, and security. Examples of service mesh platforms include Istio, Linkerd, and Consul.     

4. Containerization: Containers are lightweight, portable units of software that can run anywhere, making them an ideal choice for deploying microservices. The most popular containerization platforms are Docker and Kubernetes.     

5. Message broker: Microservices often use asynchronous messaging to communicate with each other, and a message broker provides a reliable, scalable way to send and receive messages. Popular message brokers include RabbitMQ, Apache Kafka, and Amazon SQS.     

6. Database: Microservices may use different types of databases depending on their specific requirements. Popular choices include MongoDB, Cassandra, MySQL, and PostgreSQL.     

7. Monitoring and logging: A microservices architecture can be complex, with many moving parts, so it's crucial to have tools in place to monitor the system's health and identify issues quickly. Popular monitoring and logging tools include Prometheus, Grafana, ELK stack (Elasticsearch, Logstash, and Kibana), and Splunk.      

8.  Continuous integration and deployment (CI/CD): Since microservices are deployed and scaled independently, it's essential to have a robust CI/CD pipeline in place to automate the build, test, and deployment process. Popular CI/CD tools include Jenkins, GitLab CI, and CircleCI.    

### 2. What are Resilience patterns? What is circuit breaker?     

Resilience patterns refer to a set of design principles and practices that are aimed at making software systems more resilient to failures and disruptions. These patterns are used to ensure that a system can continue to function correctly and reliably in the face of errors, failures, and other unexpected events.       

One of the key resilience patterns is the Circuit Breaker pattern. The Circuit Breaker pattern is used to prevent a system from continually trying to execute an operation that is likely to fail. The pattern is based on the concept of an electrical circuit breaker, which automatically cuts off the flow of electricity when a circuit is overloaded or experiencing a fault.    

In software, the Circuit Breaker pattern is implemented using a proxy object that sits between a client and a remote service. When the client attempts to call the service, the Circuit Breaker checks the status of the service. If the service is available and responding normally, the Circuit Breaker allows the call to proceed as usual. However, if the service is not responding or is responding slowly, the Circuit Breaker trips, and subsequent calls to the service are blocked for a specified period of time.      

During this time, the Circuit Breaker can perform a range of actions to handle the failure, such as returning a default value or an error message to the client, or attempting to connect to a backup service. Once the specified time has elapsed, the Circuit Breaker automatically resets, and subsequent calls to the service are allowed to proceed again.

The Circuit Breaker pattern is particularly useful in distributed systems where services may fail or become unavailable due to network issues, hardware failures, or other factors. By using the Circuit Breaker pattern, developers can ensure that their systems are more resilient and can continue to function even in the face of failures and disruptions.     

### 3. Features of Microservices.     

Decoupling, Componentization, Business Capabilities, Team autonomy, Continuous Delivery, Responsibility, Decentralized Governance, Agility.    

### 4. Main components of Microservices.    

1. Containers, Clustering, and Orchestrantion.    
2. Iac    
3. Cloud Infrastructure    
4. API Gateway    
5. Enterprise Service Bus    
5. Service Delivery    

### 5. Name three common tools mostly used for microservices.    

1. Wiremock     
2. Docker    
3. Hystrix      

### 6. Monolithic VS SOA VS Microservices     

Monolithic Architecture: It is "like a big container" where all the software components of an application are bundled together tightly. It is usually built as one large system ans is one code-base.    

SOA: It is a group of services interacting or communicating with each other. Depending on the nature of the communication, it can be simple data exchange or it could involve several services coordinating some activity.        

Microservice Architecture: It involves structuring an application in the form of a cluster of small, autonomous services modeled around a business domain. The dunctional modules can be deployed independently, are scalable, are aimed at achieving specific business goals, and communicate with each other over standard protocols.      

### 7. Explain spring cloud and spring boot.    
Spring Boot is an open-sourced, Java-based framework that provides its developers with a platform on which they can create stand-alone, production-grade Spring applications. In addition to reducing development time and increasing productivity, it is easily understood.      

### 8. What is the role of actuator in Spring boot?    

A spring boot actuator is a project that provides restful web services to access the current state of an application that is running in production. In addition, you can monitor and manage apllication usage in a production environment without having to code or configure any part of the applications.     

### 9. What issues are generally solved by spring clouds?     

1. Complicated issues caused by distributed systems    
2. Service Discovery issues    
3. Redundancy issues    
4. Load balancing issues    
5. Reduces performance issues     

### 10. What do you mean by Cohesion and Coupling?     

Coupling: It is defined as a relationship between softwae modules A and B, and how much one module depends on or interacts with another one. Couplings fall into three major categories. Modules can be highly coupled, loosely coupled, and uncoupled from each other. The best kind of coupling is loose coupling, which is achieved through interfaces.    

Cohesion: It is defined as a relationship between two or more parts/elements of a module that serves the same purpose. Generally, a module with high cohesion can perform a specific function efficiently without needing communication with any other modules. High cohesion enhances the functionality of the module.      

### 11. Write the fundamental characteristics of Microservice Design.     

#### Based on Business Capabilities: 
Services are divided and organized around business capabilities.      

#### Products not projects: 
A product should belong to the team that handles it.     

#### Essential messaging frameworks: 
Rely on functional messaging frameworks: Eliminate centralized service buses by embracing the concept of decentralization.      

#### Decentralized Governance: 
The development teams are accountable for all aspects of the software they produce.    

#### Decentralized data management: 
Microservices allow each service to manage its data separately.     

#### Automated infastructure: 
These systems are complete and can be deployed independently.      

#### Design for failure: 
Increase the tolerance for failure of services by focusing on continuous monitoring of the applications.       

### 12. What are the challenges that one has to face while using Microservices?     

The challenges that one has to face while using microservices can be both functional and technical as given below:     

Miroservices are always interdependent. Therefore, they must communicate with each other.    

It is heavily involved model because it is a distributed system.    

You need to be prepared for operations overhead if you are using Microservice architecture.       

It is difficult to manage configurations across different environments for all components.      

### 13. Exlain how independent microservices communicate with each other.     

Communication between microservices can take place through:    

HTTP/REST with JSON or binary protocol for request-response.    
Websockets for streaming.     
A broker or server program that uses advanced routine algorithms. RabbitMQ, Nats, Kafka, etc., can be used as message brokers; each is built to handle a particular message semantic.    

### 14. What do you mean by Domain driven design?     

DDD (Domain-Driven-Design) is basically an architectural style that is based on Object-Oriented Analysis Design approaches and principles.     

### 15. Explain OAuth.    

Generally speaking, OAuth (Open Authorization Protocol) enables users to authenticate themselves with third-party service providers. With this protocol, you can access client applications on HTTP for third-party providers such as GitHub, Facebook, etc. Using it, you can also share resources on one site with another site without requiring their credentials.      

### 16. Explain the term Eureka in Microservices     

Eureka Server, also referred to as Netflix Service Discovery Server, is an application that keeps track of all client-service applications. As every Microservice registers to Eureka Server, Eureka Server knows all the client applications running on the different ports and IP addresses. It generally uses Spring Cloud and is not heavy on the application development process.    

### 17. Explain the way to implement service discovery in microservices architecture.      

There are many ways to set up service discovery, but Netflix's Eureka is the most efficient. This is a hassle-free procedure that doesn't add much weight to the application. It also supports a wide range of web applications. A number of annotations are provided by Spring Cloud to make its use as simple as possible and to hide complex concepts.

### 18. Explain Container in Microservices

Containers are useful technologies for allocating and sharing resources. It is considered the most effective and easiest method for managing microservice-based applications to develop and deploy them individually. Using Docker, you may also encapsulate a microservice along with its dependencies in a container image, which can then be used to roll on-demand instances of the microservice without any additional work.     

### 19. What is the main role of docker in microservices?      

Docker generally provides a container environment, in which any application can be hosted. This is accomplished by tightly packaging both the application and the dependencies required to support it. These packaged products are referred to as Containers, and since Docker is used to doing that, they are called Docker containers. Docker, in essence, allows you to containerize your microservices and manage these microservices more easily.      

### 20. how to do load balance in microservice?      

Round-robin Load Balancing: With round-robin load balancing, requests are distributed in a round-robin fashion across the different instances of a service. This approach is simple and easy to implement, but it may not be the most effective way to balance the load, especially if the instances have different capabilities.     

Weighted Load Balancing: Weighted load balancing involves assigning a weight to each instance of a service based on its capabilities and load. The load balancer then distributes the requests to the instances based on their weights. This approach allows for more effective load balancing, as it takes into account the capabilities of each instance.
Least Connection Load Balancing: With least connection load balancing, the load balancer directs requests to the instance with the fewest active connections. This approach is effective at balancing the load across instances, but it requires more complex monitoring of the instances' connections.     

IP Hash Load Balancing: IP hash load balancing involves using the IP address of the client to determine which instance of a service to direct the request to. This approach ensures that requests from the same client are always directed to the same instance of the service, which can be useful for session management and other scenarios.      

Dynamic Load Balancing: Dynamic load balancing involves monitoring the load on each instance of a service and adjusting the load balancing strategy dynamically. This approach can be highly effective at balancing the load across instances, but it requires more complex monitoring and management infrastructure.
