# Q2

Selenium is a widely-used open-source automation testing framework that enables testers to automate interactions with web browsers.

# Q3

Cucumber is a behavior-driven development (BDD) tool that allows developers and testers to create and run automated acceptance tests written in a plain-text format.

# Q4

Apache JMeter is an open-source software tool that is used for load testing, performance testing, and functional testing of web applications.

# Q5

A unit test is a type of software testing that verifies the functionality of a specific portion of code, known as a "unit." A unit typically refers to the smallest testable part of an application, such as a function, method, or class.

# Q6

- Initialization: In this stage, JUnit initializes the test environment and prepares it for the execution of the tests. This includes creating objects and setting up any necessary resources, such as database connections or network sockets.
- Test Execution: This is the main stage where JUnit runs the tests. Each test method is executed in isolation from the others, and the results are recorded.
- Test Result Verification: In this stage, JUnit verifies the results of each test method to ensure that they meet the expected outcome. If a test fails, JUnit reports the failure and continues to execute the remaining tests.
- Cleanup: In the final stage, JUnit cleans up the test environment and releases any resources that were used during the test. This includes closing database connections, releasing network sockets, and removing temporary files.

# Q7

Yes, ```@BeforeAll``` method should be class level.

# Q8

Mockito is a popular open-source mocking framework for the Java programming language. It allows developers to create mock objects and stubs that simulate the behavior of real objects and dependencies, making it easier to write unit tests for complex applications.
However, Mockito also has some limitations, which developers should be aware of:

- Mockito cannot mock final classes and methods in earlier versions (prior to version 3.4.0), which can be a limitation in some cases.
- Mockito cannot mock static methods or constructors, which can be a limitation in some scenarios.
- Mockito may not be suitable for testing highly concurrent applications, as it is not designed to handle thread-safety issues.

# Q9

```@Mock``` is used to create a mock object of a class or interface. When a test class is annotated with ```@Mock```, Mockito creates a mock object of the specified class or interface, which can be used to simulate the behavior of the real object.
```@InjectMocks``` is used to inject mock objects into a class under test. When a test class is annotated with ```@InjectMocks```, Mockito injects the mock objects that have been created with @Mock into the fields of the class under test.

# Q10

Stubbing is a feature in Mockito that allows developers to define the behavior of a mock object .

# Q11

Mockito ArgumentMatchers is a feature of the Mockito mocking framework for Java that allows developers to define argument matchers for method parameters when defining stubs or verifying method invocations on mock objects.

# Q12

Hamcrest Matchers is a library of matchers for Java that provides a set of flexible, reusable, and composable matchers. It is commonly used in testing frameworks like JUnit and Mockito to create more readable and expressive tests.

# Q13

The ```@Spy``` annotation is used to create a real object and wrap it with a spy object. A spy object is a partially mocking object, which allows the developer to keep track of method invocations on the object while still calling the real methods of the object. In other words, when using ```@Spy```, you are partially mocking a real object, while with ```@Mock```, you are creating a fully mocked object.
