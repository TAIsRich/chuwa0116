### 2. what is the @configuration and @bean?
* `@Configuration` annotation indicates that the class has @Bean definition methods. So Spring container can process the class and generate Spring Beans to be used in the application. Spring `@Configuration` annotation allows us to use annotations for dependency injection. It’s better to use `@Configuration` annotation with configuration classes to make sure our spring container is behaving like the way we want it to. 

* Spring `@Bean` Annotation is applied on a method to specify that it returns a bean to be managed by Spring context. Spring Bean annotation is usually declared in Configuration classes methods. In this case, bean methods may reference other `@Bean` methods in the same class by calling them directly.

### 3. How do you handle the exception in Spring?
* `@ExceptionHandler`

    * Method level
    * used to handle the specific exceptions and sending the custom responses to the client. 
@ExceptionHandler annotation allows you to handle local exceptions of Controller
* `@ControllerAdvice`
    * class level
    * used to handle the exceptions globally.

Steps:
1. Create ErrorDetails Class
2. Create GlobalExceptionHandler class
3. Test using Postman Client.

`@ControllerAdvice` annotation is a global exception handler used to intercept and handle the exceptions thrown by the controllers across the application.
`@ExceptionHandler` annotation is used to handle specific exceptions thrown by controllers

### 4. How do you do the validations in Spring?
Validations is used to Validate the request Body and customize to return some information.

Steps:

1. import dependency in pom.xml:
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
    <version>2.7.0</version>
</dependency>
```

2. Add validation rule to payload, using annotations like @Size, @NotEmpty.

3. Add @Valid to controller to apply the rule, for example:
```
@PostMapping
public ResponseEntity<PostDTO> createPost(@Valid @RequestBody postDTO postDTO){
    return new ResponseEntity<>(postService.createPost(postDTO), HttpStatus.CREATED);
}
```
4. Check it in Postman.

### 5. What is the actuator?
Actuator brings production-ready features to our application.

Monitoring our app, gathering metrics, understanding traffic, or the state of our database become trivial with this dependency.

The main benefit of this library is that we can get production-grade tools without having to actually implement these features ourselves.

Actuator is mainly used to expose operational information about the running application — health, metrics, info, dump, env, etc. It uses HTTP endpoints or JMX beans to enable us to interact with it.

Once this dependency is on the classpath, several endpoints are available for us out of the box. As with most Spring modules, we can easily configure or extend it in many ways.

### 2. What is Spring and Springboot? What is the benfits of using Srpingboot?
Spring is a lightweight, open-source, and modular Java framework created to address the complexity of enterprise application development. It provides a comprehensive programming and configuration model for building Java-based applications in a flexible way and facilitates the use of best practices. The Spring Framework's innovation lies in making Java developers more productive while ensuring that they can be successful in their development endeavors.

Spring Boot is the most popular framework for building microservice applications with Java. It speeds up the development and deployment processes by offering intuitive default settings for unit and integration tests, web applications, and more. Spring Boot enables developers to build robust applications having secure as well as clear configurations without losing much time and effort on its complex framework.

SpringBoot makes it easy to work with Spring framework. When using Spring framework, we have to take care of all the configuration ourselves like, for making a web application, DispatcherServlet, ViewResolver etc configurations are needed. SpringBoot solves this problem through a combination of Auto Configuration and Starter projects.

### 3. What is IOC and What is DI?
* Inversion of Control (IOC) is we are passing the control of objects to Spring framework.

* Dependency injection is one of the principles that enforce IOC. Dependency Injection(DI) is a design pattern where the dependencies of a class are injected from outside, like from an xml file. It ensures loose-coupling between classes.

### 4. What is @CompnonentScan?
`@ComponentScan` defines where the Spring need to scan the bean definations and generate the beans. It directs Spring to search for components in the path specified.

When we specify `@ComponentScan` annotation on a class, then it starts scanning for the components from that package and its sub-packages, so if our class is in a different package altogether, then we will have to explicitly tell Spring to look into our package

### 5. How to define which package spring need to scan in xml and annotaiton?
* XML:
```
<context:component-scan base-package="com.packagename"></context:component-scan>
```

* Annotation:
```
@Configuration
@ComponentScan(value="com.packagename")
```

### 6. What is @SpringbootApplication?
`@SpringBootApplication` is a combination of 3 different annotations:

`@Configuration`: This annotation marks a class as a Configuration class in Java-based configuration, it allows to register extra beans in the context or import additional configuration classes `@ComponentScan`: to enable component scanning `@EnableAutoConfiguration`: to enable Spring Boot’s auto- configuration feature. These 3 annotations are frequently used together, so SpringBoot designers bundled them into one single

`@SpringBootApplication`, now instead of 3 annotations you just need to specify only one annotation on the Main class. However, if you don’t need one of these annotation depending on your requirement, then you will have to use them separately.

### 7. How many ways wo can define a bean?
There are three different ways that we can define a Spring bean:
* Class level 

    annotating class with the stereotype @Component annotation (or its derivatives) e.g. @Service, @Repository, @Controller
* Method level

    writing a bean factory method annotated with the @Bean annotation in a custom Java configuration class
* XML
    
    declaring a bean definition in an XML configuration file

### 8. What is default bean name for @Component and @Bean?
When Spring scans a class annotated with `@Component`, by default it defines a bean with beanName as the class name, starting with a lowercase letter.

When Spring parses the class, it identifies all methods annotated with `@Bean`, executes them, and registers the return value of the methods in the IoC container. By default, the method name is the Bean name.
    
### 9. What is the difference between @component and @service,@repository?
* `@Component`: It is a general purpose stereotype annotation which indicates that the class annotated with it, is a spring managed component.
* `@Controller`, `@Service` and `@Repository` are special types of `@Component`

The classes annotated with these annotations gets picked up in Component scanning and they are managed by Spring.

* `@Controller`: the classes annotated with `@Controller` will act as Spring MVC controllers. DispatcherServlet looks for `@RequestMapping` in classes that are annotated with `@Controller`. That means you cannot replace `@Controller` with `@Component`, if you just replace it with `@Component` then yes it will be managed by Spring but it will not be able to handle the requests. (Note: if a class is registered with Spring using `@Component`, then `@RequestMapping` annotations within class can be picked up, if the class itself is annotated with `@RequestMapping`) 
* `@Service`: the service layer classes that contain the business logic should be annotated with `@Service`. Apart from the fact that it is used to indicate that the class contains business logic, there is no special meaning to this annotation, however it is possible that Spring may add some additional feature to `@Service` in future, so it is always good idea to follow the convention.
* `@Repository`: the classes annotated with this annotation defines data repositories. It is used in DAO layer classes. `@Repository` has one special feature that it catches platform specific exceptions and re-throw them as one of the Spring’s unified unchecked exception i.e. DataAccessException .

### 10. How many annotaitons we can use to inject the bean?
We can use @Resource, @Autowired and @Inject to inject the bean.

### 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?
* Constructor Injection
* Setter Injection
* Field Injection

I think Constructor Injection is Better.

If we want to instantiate a class we always do it with its constructor. So if we are using constructor based injection, the only way to instantiate the class is through that constructor. If we pass the dependency through constructor it becomes evident that it is a mandatory dependency.

On the other hand, if we have a setter method in a POJO class, we may or may not set value for our class variable using that setter method. It is completely based on our need. i.e. it is optional.

So if we pass the dependency through setter method of a class it implicitly means that it is an optional dependency.

### 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.
`@Primary` indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency.

`@Qualifier` indicates specific bean should be autowired when there are multiple candidates. (If there is no primary)

### 13. What is the difference between BeanFactory and ApplicationContext in Spring?
The differences are:
- BeanFactory is the most basic version of IOC containers which should be preferred when memory consumption is critical whereas ApplicationContext extends BeanFactory, so you get all the benefits of BeanFactory plus some advanced features for enterprise applications
- BeanFactory instantiates beans on-demand i.e. when the method getBean(beanName) is called, it is also called Lazy initializer whereas ApplicationContext instantiates beans at the time of creating the container where bean scope is Singleton, so it is an Eager initializer
- BeanFactory only supports 2 bean scopes, singleton and prototype whereas ApplicationContext supports all bean scopes
- ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup, whereas BeanFactory does not register these interfaces automatically
- Annotation based dependency injection is not supported by BeanFactory whereas ApplicationContext supports it
- If you are using plain BeanFactory, features like transactions and AOP will not take effect (not without some extra steps), even if nothing is wrong with the configuration whereas in ApplicationContext, it will work
- ApplicationContext provides additional features like MessageSource access (i18n or Internationalization) and Event Publication

Use an ApplicationContext unless you have a really good reason for not doing so.


### 14. What is the Scope of a Bean? and list the examples for each scope.
Spring framework supports 5 scopes
* singleton – only one bean instance per Spring IOC container 
* prototype – it produces a new instance each and every time a bean is requested
* request – a single instance will be created and made available during complete life-cycle of an HTTP request 
* session – a single instance will be created and made available during complete life-cycle of an HTTP session
* global session – a single instance will be created during the life-cycle of a ServletContext @Scope annotation or scope attribute of bean tag can be used to define bean scopes in Spring.

### 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)
```
<bean 
  id="userService" 
  class="com.chuwa.service.UserServiceImpl" >
  <constructor-arg value="1" />
</bean>
<bean 
  id="userController" 
  class="com.chuwa.controllers.UserController" >
    <property name="userService" ref="userService" />
</bean>    
```