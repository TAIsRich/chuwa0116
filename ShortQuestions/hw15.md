##1. List all of the new learned annotations to your annotations.md
####Answer:
    The answer is in the ShortQuestions/annotations.md.

##2. what is selenium(YouTube)?
####Answer:
    Selenium is an automated testing tool for Web applications. Selenium tests run directly in the browser, just like real 
    users do. The main functions include testing compatibility with browsers and testing the functionality of system.
    The first one means testing your applications to see if it works well on differnt browsers and operating systems. The other 
    means creating regression tests to verify software functionality and user requirements. It can support for automatic 
    recording of actions and atomatic generation of test scripts in langugaes like Java, .Net, and etc.. When we implement 
    automatic testing using Selenium, test script, browser driver and the brower are required.
    
##3. what is cucumber(youtuebe)?
####Answer:
    Cucumber is a tool that can execute automated test cases using a text description language called Gherkin. Gherkin is 
    used to describe the behavior of software without knowing the specific implementation. Gherkin supports more than 40 languages, 
    including English and Chinese. Gherkin can add comments anywhere. Comments start with #, and each file ends with .feature. 
    Enter function descriptions, scenarios, and steps in the feature file.  For feature (function), each feature file must 
    start with Feature, and the description after Feature can be written casually until a Scenario appears. There can be 
    multiple Scenarios in a feature, and each Scenario contains  steps For the list, the steps use keywords such as Given, 
    When, Then, But, and, and cucumber handles these keywords in the same way, but we need to distinguish them according 
    to the scene when using them. Given- a precondition before the use case starts to execute, similar to some steps in writing 
    code setup. When- some key operation steps that the use case starts to execute, such as clicking elements, etc. 
    Then- Observation results are the verification steps in the usual use cases.

##4. what is JMeter(youtube)?
####Answer:
    JMeter is a Java-based stress testing tool developed by the Apache organization for stress testing software. It was 
    originally designed for web application testing, but later expanded to other testing areas. There are four keypoints:
    only one test plan in a script, at least one thread group in a test plan, at least one smapler, and at least one listener.
    The mechanism is that JMeter is run as threads. JMeter uses thread groups to drive multiple threads to run scripts to initiate
    load on the server under test. And each load machine can run multiple thread groups. The JMeter running scenario can be completed 
    not only in the GUI mode, but also using the command line which consumes less resources on the load machine.

##5. what is unit-test?
####Answer:
    unit test involves the testing of each unit or an individual component of the software application. The advantages of using unit 
    test are as following:
    1)refactoring: In the process of refactoring a certain business code, there is no need to worry about the side effects of 
    the code, and the use case will automatically help comprehensive testing.
    2)Facilitate maintenance: When each iteration of new functions and frequent code updates, it ensures the integrity of 
    the test. Because the previous test cases still exist. The system has good maintainability, and is convenient for 
    multiple people to develop.
    3)Quickly familiarize yourself with the code: For newcomers to the team, unit test is actually a better document, and 
    each case can reflect the specific functions and businesses contained in the code in detail.
    4)Improve code quality: If a unit test is written with very complex logic, or a function is too complex to write a 
    unit test, it means that there is a problem with module extraction, and you can warn yourself.

##6. What is the lifecircle of Junit?
####Answer:
    The test lifecycle is driven by four main annotations namely @BeforeAll, @BeforeEach, @AfterEach and @AfterAll. 
    At the same time, each test method must be marked with @Test annotation. And the complete lifecycle of a test can be seen
    in three phases. 
    1)Setup: This phase puts the the test infrastructure in place. JUnit provides class level setup (@BeforeAll) 
    and method level setup (@BeforeEach). Generally, heavy objects like databse comnections are created in class level setup while 
    lightweight objects like test objects are reset in the method level setup.
    2)Test Execution: The test execution and assertion happen with @Test. The execution result will signify a success or failure.
    3)CleanUp: This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also 
    happen at class level (@AfterAll) and method level (@AfterEach).

##7. Is @BeforeAll method should be Class level(static)?
####Answer:
    Yes. Because this method is static method, which executed only once.

##8. What is Mockito? and what is its limitations?
####Answer:
    1）Mockito is a mock testing framework based on Java development. Through Mockito, we can create and configure Mock 
    objects to simplify the testing of classes with external dependencies. The mock object is used for real objects having 
    undeterminable behavior, producing unpredictable effects, real objects which are difficult to create, some behaviors 
    of real objects are difficult to trigger, and real objects that don't actually exist yet. The general process of using Mockito
    is:  Create an externally dependent Mock object, and then inject this Mock object into the test class -> Execute the test code
    -> Verify that the test code is executed correctly.
    2)Limitations:
    1.for Mockito 3.x: cannot mock constructors(support mocking object contruction since 3.5.0)
    2.for Mockito 2.X: cannot mock constructors, static methods, equals(), hashCode(). 
    3.for Mockito 1.x: cannot mock final classes, final methods, static methods, constructors, equals(), hashCode().

##9. What is @Mock and what is @InjectMocks?
####Answer:
    1)@Mock: When applying Mockito to create a mock object, we can use @Mock annotation on the class to be simulated and returned.
    The @Mock annotation is actually shorthand for the Mockito.mock() method. And we should only use it in test classes.
    @Mock will replace any existing bean of the same type in the Spring context, or add a new bean if no bean of the same type is defined.
    2)@InjectMocks: It is used to create an instance. And in this situation, the instance can call the method of the real code.
    And the rest of the mock objects created with  @Mock or @Spy annotation will be injected into this instance.

##10. What is the stubbing?
####Answer:
    Stubbing is the act of making collaborators response to method calls in a certain way. When stubbing a method, you do 
    not care if and how many times the method is going to be called. It is just wanted to return some value or perform some 
    side effect whenever it gets called. The stub method is a virtual class, and only returns prepared fake data without 
    providing interactive verification which is  whether the method has been called and how many times it will be called. 
    And using the stub can only check the state such as whether the result data returned by the test method is correct, 
    the size of the list, etc., and whether it conforms to the assertion.

##11. what is Mockito ArgumentMatchers
####Answer:
    Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. It extends ArgumentMatchers class 
    to access all the matcher functions. 
    Mockito ArgumentMatchers is used for our mocked methods when we need to respond to a wider range of values or unknown values.
    But if a method has more than one argument, we can't just use ArgumentMatchers for only some of the arguments. Mockito 
    requires that we provide all arguments either by matchers or exact values. And noted that we can not use ArgumentMatchers
    as a return value or outside of verification or stubbing.

##12. what is Hamcrest Matchers
####Answer:
    Hamcrest Matchers is a widely used framework for unit testing in Java. Hamcrest target is to make your tests easier to 
    write and read. For this, it provides additional matcher classes which can be used in test  written with JUnit. You can 
    also define custom matcher implementations. To use Hamcrest matchers in your test you use the assertThat statement 
    followed by one or several matchers. Specifically, instead of using junit‘s numerous assert methods, we only use the 
    API's single assertThat statement with appropriate matchers. Hamcrest provides matchers for making assertions on arbitrary 
    Java objects, bean matcher to inspect properties of a Java bean, and matchers for inspecting Collections. 

##13. do you know @spy? what is difference between @spy and @Mock?
####Answer:
    1)@Spy: With annotation @Spy, it will wrap a real object and call the real method by default. Additionally, @spy also 
    has the ability same as @Mock.
    2)Both @Mock and @Spy can mock the object. But the former takes over all the methods of the object, while the latter 
    just mocks the stubbing calls, and the rest of the methods are still actual calls.

##14. briefly reading this articles
    a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse
    -ide
    b. https://www.javatpoint.com/junit-tutorial
    c. https://www.javatpoint.com/testng-tutorial
    d. https://www.javatpoint.com/jmeter-tutorial
####Answer:
    Completed.

##15. Add unit test for CommentServiceImpl, the coverage should be 100%.
####Answer:
    The answer is in the Coding/TestJava/CommentServiceImplTest.java.
![image](https://github.com/krystaZeng/ImagesRepo/raw/main/Screenshot%202023-03-08%20at%207.10.25%20PM.png)
