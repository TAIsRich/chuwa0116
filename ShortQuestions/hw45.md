### What is authentication?

Authentication is the process of verifying the identity of a user or system. It involves confirming the validity of the credentials provided by the user, such as a username and password, a security token, a biometric input (like a fingerprint or facial recognition), or any other authentication mechanism.

Authentication is a critical component of security, as it allows systems and services to ensure that only authorized users or processes are granted access to sensitive data or resources. Authentication is often implemented in conjunction with authorization, which determines what level of access or permissions a user or system is granted once they have been authenticated.

### What is authorization?

Authorization is the process of determining what level of access or permission a user or system has to a particular resource or service after they have been authenticated. It involves checking the credentials and privileges of the user, and verifying whether they are authorized to perform a specific action or access certain information.

Authorization is often implemented in conjunction with authentication, which verifies the identity of the user or system. Together, these processes help to ensure that only authorized users or processes are granted access to sensitive data or resources.

### What is the difference between authentication and authorization?

Authentication and authorization are two related but distinct concepts in computer security. The key difference between them is that authentication is the process of verifying the identity of a user or system, while authorization is the process of determining what level of access or permission that user or system has to a particular resource or service.

In other words, authentication is about confirming who you are, while authorization is about determining what you can do.

### What is HTTP Session?

HTTP Session is a mechanism used in web applications to maintain state or context information between multiple requests and responses made by a client and a server using the HTTP protocol.

When a user interacts with a web application, the server creates a session object that stores information about the user's interactions, such as their preferences, login credentials, shopping cart items, and other relevant data. This information is stored on the server-side and associated with a unique session ID, which is then sent to the client in the form of a cookie or URL parameter.

Subsequent requests from the same client include the session ID, which allows the server to retrieve the corresponding session object and restore the user's context or state. The server can also update the session object with new information or invalidate it if the session has expired or been terminated.

HTTP sessions are critical for maintaining user engagement and providing a personalized experience in web applications. They allow the server to keep track of user interactions across multiple pages or requests and ensure that the user's data and preferences are consistent and secure.

### What is Cookie?

A cookie is a small piece of data stored on the client-side (usually within a user's web browser) that is sent back to the server with every subsequent request. Cookies are commonly used to store information about the user's preferences, session data, and other relevant information related to their interaction with a website.

When a user visits a website, the server can send one or more cookies to the client in the HTTP response. The client's browser stores the cookie(s) and sends them back to the server with every subsequent request. The server can then use the information in the cookie to personalize the user's experience or maintain state between requests.

Cookies can be either session-based or persistent. Session-based cookies are stored in the browser's memory and are deleted when the browser is closed. Persistent cookies, on the other hand, are stored on the user's device and remain there until they expire or are manually deleted.

Cookies can be used for various purposes, such as authentication, personalization, tracking, and analytics. However, their use has raised privacy concerns, as they can be used to track user behavior across multiple websites and potentially collect sensitive information. As a result, many web browsers allow users to control or block cookies, and websites must comply with data privacy regulations when using cookies.

### What is the difference between Session and Cookie?

Session and cookie are two related but distinct concepts used in web applications to maintain state or context information between multiple requests and responses made by a client and a server.

The main difference between session and cookie is that session data is stored on the server-side, while cookie data is stored on the client-side.

### How do we use session and cookie to keep user information across the the application?

See above.

### What is JWT?

JWT stands for JSON Web Token. It is a compact, URL-safe means of representing claims to be transferred between two parties. JWTs are often used for authentication and authorization purposes in web applications.

A JWT consists of three parts: a header, a payload, and a signature. The header contains information about the algorithm used to sign the token. The payload contains the claims or statements about an entity (such as a user) and additional metadata. The signature is used to verify the integrity of the token and ensure that it has not been tampered with.

JWTs are typically issued by an authentication server or identity provider after a user has successfully authenticated. The token is then sent to the client and included in the headers or body of subsequent requests to the application's APIs. The server can then verify the token's signature and decode the payload to determine the user's identity and authorization status.

JWTs have several advantages over traditional session-based authentication:

- Stateless: Since JWTs contain all the necessary information to authenticate a user, the server does not need to maintain a session or store state information about the user.
- Portable: JWTs can be easily passed between multiple systems and APIs, as they are self-contained and can be verified without needing to access a central database or server.
- Security: JWTs are cryptographically signed, ensuring that they have not been tampered with and that the claims contained in the payload are trustworthy.
- Extensible: JWTs can be extended to include additional claims, such as user roles, permissions, or other custom data.

### What is spring security filter?

Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications. It provides a set of core security features out-of-the-box, such as authentication, authorization, and session management, as well as a range of extension points for customizing and extending its functionality.

At its core, Spring Security is implemented as a set of servlet filters that intercept and process HTTP requests and responses. These filters are responsible for enforcing security policies, such as authentication and authorization, and performing actions such as redirecting the user to a login page or setting up a session for authenticated users.

The Spring Security filter chain consists of multiple filters, each with a specific responsibility. The filters are executed in a specific order, with each filter processing the request and forwarding it to the next filter in the chain. The filter chain is usually configured in the application's Spring configuration file, where you can specify which filters to use and how they should be configured.

Some of the core filters in the Spring Security filter chain include:

- Authentication filter: Responsible for performing authentication and setting up a session for authenticated users.
- Authorization filter: Checks if the user is authorized to access the requested resource or perform the requested action.
- Session management filter: Manages user sessions and enforces session policies, such as maximum session duration or concurrent session control.
- CSRF filter: Protects against Cross-Site Request Forgery attacks by validating tokens on all POST, PUT, DELETE, and PATCH requests.

In summary, Spring Security filters are the core components of the Spring Security framework, responsible for enforcing security policies and processing HTTP requests and responses. By configuring and customizing the filter chain, you can control the authentication and authorization behavior of your application and ensure that it is secure and compliant with industry standards.

### How does JWT work?

JWT (JSON Web Token) works by allowing the server to generate a token that contains user information and signing it using a secret key or private key. This token is then passed to the client and included in the headers or body of subsequent requests to the application's APIs. The server can then verify the token's signature and decode the payload to determine the user's identity and authorization status.

Here are the steps involved in the JWT workflow:

1. Authentication: The user logs in to the application and provides their credentials. The server verifies the credentials and generates a JWT token.
2. Token generation: The server generates a JWT token that contains user information such as the user ID, name, email, and any additional metadata or claims. This token is signed using a secret key or private key to prevent tampering.
3. Token storage: The token is typically stored on the client-side, either in a cookie or local storage.
4. API requests: The client includes the JWT token in the headers or body of subsequent requests to the application's APIs.
5. Token verification: The server verifies the token's signature and decodes the payload to determine the user's identity and authorization status. If the token is valid, the server returns the requested data or performs the requested action.
6. Token refresh: If the token has expired, the server can generate a new token and send it back to the client.

### Describe some Encoder to encode Password.

In a web application, it is important to store user passwords in an encrypted and secure format to prevent unauthorized access. Password encryption is typically done using an encoder, which takes the plain text password as input and generates a hashed or encrypted version of the password that can be stored in the database. Here are some common password encoders used in web applications:

1. BCryptPasswordEncoder: This is a widely-used password encoder that is part of the Spring Security framework. It generates a hash of the password using the BCrypt algorithm, which is considered a strong hashing algorithm. The BCryptPasswordEncoder can be configured with a strength value that determines the number of rounds used to generate the hash, making it more difficult for attackers to crack the password.
2. PBKDF2PasswordEncoder: This encoder uses the PBKDF2 (Password-Based Key Derivation Function 2) algorithm to generate a hash of the password. It takes several parameters, including a salt value and an iteration count, which can be configured to increase the strength of the hash.
3. SCryptPasswordEncoder: This encoder uses the scrypt key derivation function to generate a hash of the password. The scrypt algorithm is designed to be memory-hard, making it difficult to perform brute-force attacks against the hashed password.
4. Argon2PasswordEncoder: This is a newer password encoder that uses the Argon2 hashing algorithm to generate a hash of the password. Argon2 is considered a highly secure algorithm and is recommended by the Password Hashing Competition (PHC) for password hashing.

In summary, password encoders are used to generate a hashed or encrypted version of a user's password, which can be securely stored in the database. There are several different encoders available, each with its own strengths and weaknesses. It is important to choose an encoder that is appropriate for your application's security requirements and to configure it properly to ensure the strongest possible protection for user passwords.

### What is AuthenticationFilter, AuthenticationManager, AuthenticationProvider, and UserDetailService?

In Spring Security, AuthenticationFilter, AuthenticationManager, AuthenticationProvider, and UserDetailService are key components of the authentication and authorization process:

1. AuthenticationFilter: This is a Spring Security filter that intercepts incoming authentication requests and extracts the user's credentials from the request, typically from the request headers or request body. The AuthenticationFilter then creates an Authentication object and passes it to the AuthenticationManager to authenticate the user.
2. AuthenticationManager: This is an interface that is responsible for managing the authentication process. It delegates the authentication request to one or more AuthenticationProviders, which are responsible for authenticating the user. The AuthenticationManager returns the Authentication object if the user is authenticated, or throws an AuthenticationException if the authentication fails.
3. AuthenticationProvider: This is an interface that is responsible for authenticating a user. It uses the UserDetailService to retrieve the user's details and then verifies the user's credentials. If the user is authenticated, the AuthenticationProvider creates an Authentication object containing the user's principal (username) and credentials (password) and sets its authentication status to true.
4. UserDetailsService: This is an interface that is used to load user-specific data. It is typically implemented to retrieve user details such as username, password, and roles from a database or other data source. The UserDetailsService is used by the AuthenticationProvider to authenticate a user.

Together, these components provide a comprehensive authentication and authorization solution for Spring Security applications. The AuthenticationFilter extracts the user's credentials and creates an Authentication object, which is then passed to the AuthenticationManager. The AuthenticationManager delegates the authentication request to one or more AuthenticationProviders, which use the UserDetailService to retrieve user details and authenticate the user. By combining these components, developers can create a secure and reliable authentication and authorization mechanism for their Spring Security applications.

### What is the disadvantage of Session? How to overcome the disadvantage?

One of the main disadvantages of using sessions is that they can consume a lot of server memory if they are not managed properly. This is because each session created on the server takes up memory resources to store the session data. In addition, if a large number of users are using the application simultaneously, the server may run out of memory, resulting in poor performance or even a crash.

To overcome this disadvantage, there are several strategies that can be employed:

1. Use short-lived sessions: By setting shorter session timeouts, the server can release memory resources more frequently, resulting in better memory management.
2. Store session data in a database or cache: Instead of storing session data in memory, the data can be stored in a database or cache, freeing up server memory resources. This can also make session data available across multiple server instances in a load-balanced environment.
3. Use stateless authentication: Stateless authentication using JWTs (JSON Web Tokens) eliminates the need for sessions altogether. This approach stores authentication information in the token itself, removing the need for a session to keep track of the user's authenticated state.
4. Implement server clustering: In a clustered environment, the load can be distributed across multiple servers, each handling a portion of the user traffic. This can help prevent any one server from running out of memory and provide a more scalable solution.

By implementing these strategies, the disadvantages of using sessions can be minimized or eliminated, allowing for more efficient and scalable web applications.

### How to get value from application.properties?

In Spring Boot, you can use the `@Value` annotation to inject values from `application.properties` or other configuration files into your Java classes.

Here's an example:

1. Define the property in `application.properties`:

   ```
   my.property=value
   ```

2. Use the `@Value` annotation in your Java class to inject the property value:

   ```java
   @Component
   public class MyClass {
   
       @Value("${my.property}")
       private String myProperty;
   
       // ...
   }
   ```

In this example, the `@Value` annotation is used to inject the value of the `my.property` property into the `myProperty` field of the `MyClass` class. The `${my.property}` placeholder is replaced with the actual value of the property at runtime.

Note that the `@Value` annotation can be used to inject values from a variety of sources, including system properties, environment variables, and other configuration files. By default, Spring Boot searches for `application.properties` and `application.yml` files on the classpath, but you can also specify a custom location for your configuration files using the `spring.config.location` property.

### What does configure(HttpSecurity http) do?

The `configure(HttpSecurity http)` method is used to configure the security settings for HTTP requests. This method defines which URLs are secured and which are not, and specifies the type of authentication required for each secured URL.

Here's an example:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
 
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/user/**").hasRole("USER")
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .and()
            .logout()
                .logoutSuccessUrl("/")
                .and()
            .csrf()
                .disable();
    }
 
    // ...
}
```

In this example, the `authorizeRequests()` method is used to define the URL patterns and the roles required to access them. The `formLogin()` and `logout()` methods configure the login and logout behavior for the application. Finally, the `csrf()` method is used to disable CSRF protection.

### What does configure(AuthenticationManagerBuilder auth) do?

The `configure(AuthenticationManagerBuilder auth)` method is used to configure the authentication mechanism used by the application. This method defines the user authentication and authorization logic used by the application.

Here's an example:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
 
    @Autowired
    private UserDetailsService userDetailsService;
 
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService)
            .passwordEncoder(passwordEncoder());
    }
 
    // ...
}
```

In this example, the `userDetailsService()` method is used to configure the user authentication mechanism for the application. The `passwordEncoder()` method is used to configure the password encryption used by the application. By default, Spring Security uses the `BCryptPasswordEncoder` to encrypt passwords.

Overall, `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)` are important methods used to configure the security settings for an application in Spring Security.

### What is Spring security authentication and authorization?

Spring Security is a powerful and highly customizable framework for securing Java applications. It provides a comprehensive set of tools and features for implementing authentication and authorization in your application.

Authentication:

Authentication is the process of verifying the identity of a user. In Spring Security, authentication can be performed using a variety of mechanisms, including form-based authentication, token-based authentication, and social login. The framework provides a flexible and extensible authentication mechanism that can be customized to meet the specific needs of your application.

Authorization:

Authorization is the process of determining whether a user has the necessary permissions to access a particular resource. In Spring Security, authorization is typically based on roles and permissions, which are defined in a security configuration file. The framework provides a powerful and flexible authorization mechanism that allows you to define fine-grained access control policies based on the user's role, the resource being accessed, and other factors.

Spring Security provides several key features to support authentication and authorization, including:

- UserDetailsService: This interface is used to load user-specific data, such as the user's username, password, and authorities. You can implement this interface to provide a custom user data store, such as a database or LDAP directory.
- AuthenticationProvider: This interface is used to perform authentication against a user data store. You can implement this interface to provide a custom authentication mechanism, such as a single sign-on (SSO) service or a token-based authentication system.
- AuthenticationManager: This interface is used to manage the authentication process. It delegates the authentication request to one or more authentication providers, and returns an authentication token that represents the authenticated user.
- UserDetails: This interface represents the user-specific data that is loaded by the UserDetailsService. It typically contains the user's username, password, and authorities.
- GrantedAuthority: This interface represents the permission granted to a user. It is used to define the user's roles and permissions.

Overall, Spring Security provides a comprehensive set of tools and features for implementing authentication and authorization in your Java application. With its flexible and extensible architecture, you can customize the security settings to meet the specific needs of your application.