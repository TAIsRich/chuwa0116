### What is JPA? And what is Hibernate?

JPA (Java Persistence API) is a Java specification for accessing, persisting, and managing data between Java objects/classes and a relational database. It defines a standard way to interact with a database, which can be implemented by different persistence providers like Hibernate, EclipseLink, etc.

Hibernate is an open-source, Java-based ORM (Object-Relational Mapping) framework that provides a framework to map Java classes to database tables, and map Java data types to SQL data types. It implements the Java Persistence API (JPA) specification and provides a powerful and flexible way to access and manage relational databases from within Java applications. Hibernate also provides additional features, such as caching, lazy loading, and transaction management, which are not part of the JPA specification.

In short, JPA is a specification for accessing and managing data in Java applications, and Hibernate is a specific implementation of the JPA specification, providing additional features and a powerful and flexible approach to working with databases from Java applications.

### What is Hikari? What are the benefits of connection pool?

Hikari is a popular and high-performance JDBC (Java Database Connectivity) connection pooling library for Java applications. It provides a fast, efficient, and reliable way to manage database connections in a Java application.

Regarding the benefits of a connection pool, a connection pool is a cache of database connections maintained so the connections can be reused when new requests to the database are required. Some of the benefits of using a connection pool include:

1. Improved performance: By reusing existing connections, a connection pool can reduce the overhead of creating a new connection for each database request, which can greatly improve the overall performance of your application.
2. Increased scalability: Connection pools can handle a large number of database connections and can scale to accommodate growing numbers of database requests.
3. Reduced resource overhead: Connection pools can reduce the resource overhead of maintaining many open database connections, as only a limited number of connections are created and maintained in the pool.
4. Improved reliability: Connection pools can provide improved reliability by detecting and recovering from failed database connections and ensuring that connections are returned to the pool once they are no longer in use.
5. Improved security: Connection pools can also provide additional security features, such as connection password encryption and protection against SQL injection attacks.

Hikari specifically provides a number of benefits compared to other connection pooling libraries, including: high performance, low overhead, and automatic tuning for optimal performance. Additionally, it has a simple and easy-to-use configuration and is well documented, making it a popular choice for Java developers.

### Annotations see annotations.md

### What is the cascade = CascadeType.ALL, orphanRemoval = true?

The `cascade` and `orphanRemoval` attributes are used in JPA entity relationships to specify the behavior of the relationship when the related entities are persisted, updated, or deleted.

The `cascade` attribute is used to specify the operations that should be cascaded from the source entity to the target entity. For example, if `cascade = CascadeType.ALL`, any operations performed on the source entity will be automatically cascaded to the target entity. The `CascadeType.ALL` setting specifies that all operations (`PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, and `DETACH`) should be cascaded.

The `orphanRemoval` attribute is used to specify whether or not entities that are no longer referenced by the source entity should be removed from the database. If `orphanRemoval = true`, any entities in the relationship that are no longer referenced by the source entity will be automatically removed from the database.

### What are the other CascadeType and their features? In which situation do we choose which?

The `CascadeType` enum defines several options for cascading operations from the source entity to the target entity in a JPA entity relationship. Here is a list of the `CascadeType` options and their features:

- `CascadeType.PERSIST`: Cascade the persist operation to the target entity.
- `CascadeType.MERGE`: Cascade the merge operation to the target entity.
- `CascadeType.REFRESH`: Cascade the refresh operation to the target entity.
- `CascadeType.REMOVE`: Cascade the remove operation to the target entity.
- `CascadeType.DETACH`: Cascade the detach operation to the target entity.
- `CascadeType.ALL`: Cascade all operations to the target entity.

The choice of which `CascadeType` to use depends on the desired behavior of the relationship between the source and target entities. For example, if you want changes made to the source entity to automatically update the target entity in the database, you might choose to use `CascadeType.MERGE`. On the other hand, if you want to automatically delete the target entity when the source entity is deleted, you might choose to use `CascadeType.REMOVE`.

It is important to understand the implications of each `CascadeType` option and to choose carefully based on the requirements of your application. For example, using `CascadeType.REMOVE` can cause unexpected results if you are not careful to manage the relationship between the source and target entities. Similarly, using `CascadeType.ALL` can lead to complex behavior and may not be suitable for all use cases.

It's also worth noting that the `CascadeType` options can be combined, so you can specify multiple cascading operations in a single relationship. For example, you might choose to use `cascade = {CascadeType.MERGE, CascadeType.REFRESH}` to cascade both the merge and refresh operations to the target entity.

### What is fetch = FetchType.LAZY, fetch = FetchType.EAGER? What is the difference? In which situation you choose which one?

In JPA, the `FetchType` enum is used to specify how the data for a relationship should be loaded from the database. There are two main options for `FetchType`: `LAZY` and `EAGER`.

- `FetchType.LAZY`: Specifies that the data for the relationship should be loaded lazily, i.e., only when it is actually accessed. This can improve performance by avoiding unnecessary database queries, but it also means that the data may not be available when you need it.
- `FetchType.EAGER`: Specifies that the data for the relationship should be loaded eagerly, i.e., as soon as the parent entity is loaded from the database. This ensures that the data is always available, but it can also result in increased database query overhead and reduced performance.

The choice of `FetchType` depends on the specific requirements of your application. If you expect to access the data for a relationship frequently, you may choose to use `FetchType.EAGER` to ensure that the data is always available. On the other hand, if you rarely access the data for a relationship, you may choose to use `FetchType.LAZY` to improve performance.

It is important to understand the trade-offs between `LAZY` and `EAGER` and to choose the appropriate option based on the needs of your application. In general, it is a good idea to start with `LAZY` and switch to `EAGER` if you encounter performance issues or data unavailability.

### What are the rules of JPA repository method naming conventions? Shall we implement the method by ourselves? Could you list some examples?

JPA repository method naming conventions are conventions for naming the methods in a JPA repository interface. These conventions are used by the JPA implementation (such as Hibernate) to automatically generate the appropriate SQL queries for the methods defined in the repository.

The rules of JPA repository method naming conventions are based on the Spring Data project, which provides a set of standard naming conventions for common data access operations. Some of the most commonly used naming conventions are:

1. Find by ID: To find an entity by its primary key, you can use the findById method, which is automatically generated by the JPA implementation.
2. Find All: To find all entities of a given type, you can use the findAll method, which is automatically generated by the JPA implementation.
3. Find by attribute: To find entities by a specific attribute, you can use the findByAttribute method, where Attribute is the name of the attribute you want to search by. For example, findByLastName to find all entities with a specific last name.
4. Count: To count the number of entities of a given type, you can use the count method, which is automatically generated by the JPA implementation.

Here's an example of a simple JPA repository interface:

```java
public interface CustomerRepository extends JpaRepository<Customer, Long> {
 
    Optional<Customer> findById(Long id);
 
    List<Customer> findByLastName(String lastName);
 
    Long countByLastName(String lastName);
}
```

In this example, the `CustomerRepository` interface extends `JpaRepository` and specifies the type of entity (`Customer`) and its primary key type (`Long`). The methods defined in the repository follow the JPA repository method naming conventions and can be used to perform common data access operations on the `Customer` entity.

Note that you do not need to implement the methods yourself, as the JPA implementation (such as Hibernate) will automatically generate the appropriate SQL queries for the methods defined in the repository based on the naming conventions.

For more naming conventions, see [this](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords).

### What is JPQL?

JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax. But it won’t affect the database directly.

JPQL can retrieve information or data using SELECT clause, can do bulk updates using UPDATE clause and DELETE clause. EntityManager.createQuery() API will support for querying language.

### Annotations see annotations.md

### What is HQL and Criteria Queries?

- HQL is to perform both select and non-select operations on the data, but Criteria is only for selecting the data, we cannot perform non-select operations using criteria.
- HQL is suitable for executing Static Queries, where as Criteria is suitable for executing Dynamic Queries.

- HQL doesn’t support pagination concept, but we can achieve pagination with Criteria.
- Criteria used to take more time to execute then HQL.
- With Criteria we are safe with SQL Injection because of its dynamic query generation but in HQL as your queries are either fixed or parametrized, there is no safe from SQL Injection.

### What is EntityManager?

The `EntityManager` API is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities.

### What is SessionFactory and Session?

`SessionFactory` is a factory class for `Session` objects. It is available for the whole application while a `Session` is only available for particular transaction.

`Session` is short-lived while `SessionFactory` objects are long-lived. `SessionFactory` provides a second level cache and `Session` provides a first level cache.

### What is Transaction? How to manage your transaction?

A database transaction is a sequence of actions that are treated as a single unit of work. These actions should either complete entirely or take no effect at all.

### What is hibernate Caching?

Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database. It is very useful when you need to fetch the same kind of data multiple times.

### What is the difference between first-level cache and second-level cache?

The First level cache is **by default enabled** by Hibernate itself. The session object maintains the first-level cache.

An application can have many sessions. Data hold by one session object is not accessible to the entire application — means the data of a particular session is not shared with other sessions of the application. So you can use the first-level cache to store local data i.e. required by the session itself.

When you query an entity or object, for the very first time it is retrieved from the database and stored into the first-level cache (associated with the hibernate session). If we query for the same entity or object again with the same session object, it will be loaded from cache and no SQL query will be executed.

The second-level cache is **by default disabled**, the developer needs to enable it explicitly, and the SessionFactory object is responsible to maintain it. The second-level cache is accessible by the entire application means data hold by SessionFactory can be accessible to all the sessions. Keep in mind that, once the session factory is closed all the cache associated with that is also removed from the memory.

When hibernate session try to load an entity, it will first find into the first-level cache, if it does not found then it will look into the second-level cache and return the response (if available), but before returning the response it will store that object/data into first-level also so next time no need to come at the session-level. When data is not found in the second level then it will go to the database to fetch data. Before returning a response to the user it will store that object/data into both levels of cache so next time it will be available at cache stages only.

[reference](https://medium.com/swlh/what-is-hibernate-caching-introduction-of-level-1-level-2-cache-8ea7339a5052#:~:text=Hibernate%20caching%20acts%20as%20a,kind%20of%20data%20multiple%20times.)

### Write a simple factory design pattern.

```java
public interface Animal {
    void makeSound();
}

public class Dog implements Animal {
    public void makeSound() {
        System.out.println("Woof!");
    }
}

public class Cat implements Animal {
    public void makeSound() {
        System.out.println("Meow!");
    }
}

public class AnimalFactory {
    public Animal createAnimal(String type) {
        if (type.equalsIgnoreCase("Dog")) {
            return new Dog();
        } else if (type.equalsIgnoreCase("Cat")) {
            return new Cat();
        } else {
            return null;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        AnimalFactory animalFactory = new AnimalFactory();
        Animal myDog = animalFactory.createAnimal("Dog");
        Animal myCat = animalFactory.createAnimal("Cat");

        myDog.makeSound(); // output: Woof!
        myCat.makeSound(); // output: Meow!
    }
}

```

