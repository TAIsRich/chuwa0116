
### 4. what is JPA? and what is Hibernate?
JPA use JDBC to CRUD database, and also transfer result from database to Java Entities.

Using JPA, we can map a Java class or bean to a table. The members of the class map columns in the table. When this mapping is defined, JPA can write queries on its own. It takes the responsibility of creating and executing queries for CRUD operations.

The Java Persistence API (JPA) is a specification of Java. It is used to persist data between Java object and relational database. JPA acts as a bridge between object-oriented domain models and relational database systems.

JPA is a standard of Object Relational Mapping. It is an interface that defines a set of annotations for creating the object relational mapping.

As JPA is just a specification, it doesn't perform any operation by itself. It requires an implementation. So, ORM tools like Hibernate, TopLink and iBatis implements JPA specifications for data persistence.

Hibernate is an open source object relational mapping (ORM) tool that provides a framework to map object-oriented domain models to relational databases for web applications.

### 5. What is Hiraki? what is the benefits of connection pool?
* Hikari is a JDBC DataSource implementation that provides a connection pooling mechanism.
* Connection pools promote the reuse of connection objects and reduce the number of times that connection objects are created. Connection pools significantly improve performance for database-intensive applications because creating connection objects is costly both in terms of time and resources.

### 6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.
* @OneToOne (bidirectional)

specify a one-to-one database relationship between two tables
```Java
@Entity
@Table(name = "student")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne(mappedBy = "student", cascade = CascadeType.ALL, orphanRemoval = true, fetch=FetchType.LAZY)
    private Tuition tuition;

    /* Getters and setters */   
}
```
```Java
@Entity
@Table(name = "tuition")
public class Tuition {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Double fee;

    //what column in Tuition table has the FK
    @JoinColumn(name = "student_id")
    @OneToOne(fetch = FetchType.LAZY)
    private Student student;

    /* Getters and setters */    
}
```

* @OneToMany (bidirectional)

specify a one-to-many database relationship between two tables
```Java
@Entity
@Table(name = "university")
public class University {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "university", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Student> students;

    /* Getters and setters */
}
```
```Java
@Entity
@Table(name = "student")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "university_id")
    private University university;

    /* Getters and setters */
}
```

* @ManyToMany(bidirectional)

specify a many-to-many database relationship between two tables
```
@Entity
@Table(name="course")
public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private Double fee;

    @ManyToMany(mappedBy = "courses")
    private Set<Student> students;

    /* Getters and setters */
}
```
```
@Entity
@Table(name="student")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(cascade = {
            CascadeType.PERSIST,
            CascadeType.MERGE
    })
    @JoinTable(
            name = "student_course",
            joinColumns = {@JoinColumn(name = "student_id")},
            inverseJoinColumns = {@JoinColumn(name = "course_id")}
    )
    private Set<Course> courses;

    /* Getters and setters */
}
```



### 7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?
* cascade = CascadeType.ALL means that All cascade operations on owning entity applied to related entity.

| CascadeType  | features |
| ------------- |:-------------:|
| Persist     | Owning entity saved => related entity saved|
| Merge      | Owning entity merged => related entity merged|
| Refresh  |Owning entity refreshed => related entity refreshed|
| Remove  |Owning entity removed => related entity removed|
| Detach  |Owning entity detached => related entity detachec|

* orphanRemoval = true means that dependent entities are removed when the relationship to their "parent" entity is destroyed.



### 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
* FetchType.EAGER

    Eager fetch means that when a record is fetched from the database, all the associated records from related tables are also fetched. So if we fetch a tournament record, all the registrations for the tournament are also fetched.
    
    * when we fetch post, JPA also fetch comment at the same time.

    
* FetchType.LAZY

    Lazy fetch fetches the records only when they are needed.
    
    * If we don't need data from comment, JPA doesn't fetch it
    * Onyly fetch data from post
    * when we need data from comment, then JPA fecth comment data


### 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?
* Spring data JPA has its own naming conventions for methods. Following these conventions we can build sophisticated queries. These conventions are called also called as method name strategies. These strategies have defined set of keyword to use in method names. Based on the formed method name, method performs predefined operations. 

* No. We don't need to implement the method by ourselves.
```Java
public interface  StudentRepository extends CrudRepository<Student, Long>{

        List<Student> findByStudentId(Long studentId);
        List<Student> findByStudentIdLessThanAndMarksGreaterThan(Long studentId, Long marks);
}
@Service("studentService")
public class StudentService {

        @Autowired

        private StudentRepository repository;
        
        public void test() {

                List<Student> students1 = repository.findByStudentId(1L);

                students1.forEach(student1 -> System.out.println(student1));
                List<Student> students2 = repository.findByStudentIdLessThanAndMarksGreaterThan(3L, 99L);

                students2.forEach(student2 -> System.out.println(student2));

        }
}
```
## Part 2

### 3. What is JPQL?
JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax. But it won’t affect the database directly.

### 4. What is @NamedQuery and @NamedQueries?
* `@NameQueries`: to define the multiple named queries.

* `@NameQuery`: to define the single named query.

### 5. What is @Query? In which Interface we write the sql or JPQL?
* If we use the `@Query` annotation the method name can violate the JPA naming convention, but it is best to use the method name to understand the purpose of the method.

* We write the sql or JPQL in the Repository interface.

### 6. What is HQL and Criteria Queries?
* HQL is to perform both select and non-select operations on the data,  but Criteria is only for selecting the data, we cannot perform non-select operations using criteria
* HQL is suitable for executing Static Queries, where as Criteria is suitable for executing Dynamic Queries
* HQL doesn’t support pagination concept, but we can achieve pagination with Criteria
* Criteria used to take more time to execute then HQL
* With Criteria we are safe with SQL Injection because of its dynamic query generation but in HQL as your queries are either fixed or parametrized, there is no safe from SQL Injection.

### 7. What is EnityManager?
A JPA `EntityManager` manages connection to a database as well as to database operations. `EntityManager` is associated with a PersistenceContext . All operations that are performed in a specific session are stored inside the `PersistenceContext`.
`EntityManager` is the interface to the Persistence Context . All operations on the entity go through the `EntityManager`. We will declare an `EntityManager` object in our class and mark it with the `@PersistenceContext` annotation.

`EntityManager` provides a number of methods that perform `SELECT`, `INSERT`, `UPDATE`, and `DELETE` queries.

### 8. What is SessionFactory and Session?
**SessionFactory** is an interface. SessionFactory can be created by providing Configuration object, which will contain all DB related property details pulled from either hibernate.cfg.xml file or hibernate.properties file. SessionFactory is a factory for Session objects.

We can create one SessionFactory implementation per database in any application. If your application is referring to multiple databases, then you need to create one SessionFactory per database.

The SessionFactory is a heavyweight object; it is usually created during application start up and kept for later use. The SessionFactory is a thread safe object and used by all the threads of an application.

A **Session** is used to get a physical connection with a database. The Session object is lightweight and designed to be instantiated each time an interaction is needed with the database. Persistent objects are saved and retrieved through a Session object.

The session objects should not be kept open for a long time because they are not usually thread safe and they should be created and destroyed them as needed. The main function of the Session is to offer, create, read, and delete operations for instances of mapped entity classes.

### 9. What is Transaction? how to manage your transaction?
* A transaction simply represents a unit of work. In such case, if one step fails, the whole transaction fails (which is termed as atomicity). A transaction can be described by ACID properties (Atomicity, Consistency, Isolation and Durability).
* commit or roll back

### 10. What is hibernate Caching?
Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database. It is very useful when you need to fetch the same kind of data multiple times.

### 11. What is the difference between first-level cache and second-level cache?
* First-level cache
    * Hibernate first level cache is session specific, that’s why when we are getting the same data in same session there is no query fired whereas in other session query is fired to load the data.
    * Hibernate first level cache can have old values — Two session works on the same object, the second session update the object and save to database, but it won’t reflect in the first session cache.
* Second-level cache : When an entity instance is looked up by its id and if second-level caching is enabled for that entity, the following happens:
    1. If an instance is already present in the first-level cache, it is returned from there
    2. If an instance is not found in the first-level cache, and the corresponding instance state is cached in the second-level cache, then the data is fetched from there and an instance is assembled and returned
    3. Otherwise, the necessary data are loaded from the database and an instance is assembled and returned

### 13. Write a simple factory design pattern.

```
public abstract class Computer {
    
    public abstract String getRAM();
    public abstract String getHDD();
    public abstract String getCPU();
    
    @Override
    public String toString(){
        return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU();
    }
}

public class PC extends Computer {

    private String ram;
    private String hdd;
    private String cpu;
    
    public PC(String ram, String hdd, String cpu){
        this.ram=ram;
        this.hdd=hdd;
        this.cpu=cpu;
    }
    @Override
    public String getRAM() {
        return this.ram;
    }

    @Override
    public String getHDD() {
        return this.hdd;
    }

    @Override
    public String getCPU() {
        return this.cpu;
    }
}

public class Server extends Computer {

    private String ram;
    private String hdd;
    private String cpu;
    
    public Server(String ram, String hdd, String cpu){
        this.ram=ram;
        this.hdd=hdd;
        this.cpu=cpu;
    }
    @Override
    public String getRAM() {
        return this.ram;
    }

    @Override
    public String getHDD() {
        return this.hdd;
    }

    @Override
    public String getCPU() {
        return this.cpu;
    }

}

public class ComputerFactory {

    public static Computer getComputer(String type, String ram, String hdd, String cpu){
        if("PC".equalsIgnoreCase(type)) return new PC(ram, hdd, cpu);
        else if("Server".equalsIgnoreCase(type)) return new Server(ram, hdd, cpu);
        
        return null;
    }
}

public class TestFactory {

    public static void main(String[] args) {
        Computer pc = ComputerFactory.getComputer("pc","2 GB","500 GB","2.4 GHz");
        Computer server = ComputerFactory.getComputer("server","16 GB","1 TB","2.9 GHz");
        System.out.println("Factory PC Config::"+pc);
        System.out.println("Factory Server Config::"+server);
    }

}

//Output:
Factory PC Config::RAM= 2 GB, HDD=500 GB, CPU=2.4 GHz
Factory Server Config::RAM= 16 GB, HDD=1 TB, CPU=2.9 GHz
```