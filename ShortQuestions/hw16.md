##1. list all of the new annotations you learned to your annotations.md

##2. Document the microservice architecture and components/tools/dependencies
####Answer:
    It involves structuring an application in the form of a cluster of small, autonomous services modeled around a business domain. 
    The functional modules can be deployed independently, are scalable, are aimed at achieving specific business goals, and 
    communicate with each other over standard protocols.
![the image](https://github.com/krystaZeng/ImagesRepo/raw/main/Screenshot%202023-03-13%20at%206.19.22%20PM.png)
    
    1)Spring Cloud: it is a system that integrates with external systems. This is a short-lived framework designed to build applications
    quickly. It contributes significantly to microservice architecture due to its association with finite amounts of data processing.
    2)API Gateway: Zull/Spring Cloud Gateway
    It can forward external request to specific services, serving as routing. Additionally, it can be used to implement central 
    functionalities such as logging of all requests. And it can implement the login, send information about the current user
    with the HTTP requests, and thereby implement authentication.
    *Dependency:
```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```
    * Add the code in the application.yml of API_Gateway
```
cloud:
    gateway:
        routes:
            - id: CITIZEN-SERVICE
              uri:
                lb://CITIZEN-SERVICE
              predicates:
                - Path=/citizen/**
```
    3)Service Discovery&& Service Registry: Eureka
    Eureka can regist service by serviceid, monitor service health status, auto-register new services.
    Stage1: Set up EurekaServer: import the eureka-server dependency -> add @EnableEurekaServer annotation ->
    configure eureka server address in the application.yml.
    Stage2: Service registry: import eureka-client dependency -> add @EnableEurekaClient in client service -> give service a 
    service id – spring.application.name = serviceid
    Stage3: Service discovery: import eureka-client dependency -> configure client in the application.yml ->
    add @LoadBalanced annotation to the RestTemplate -> call the name of the provided service remotely.
    *Dependency:
```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```
    4)Load Balancer: Ribbon, Nginx
    Load balancing enables the service to scale well and stay highly available when the traffic load increases. Load balancing 
    is facilitated by load balancers, making them a key component in the web application architecture. To ensure that the 
    user request is always routed to the machine that is up and runing, load balancers regularly perform health checks on the 
    machines in the cluster.
    *@LoadBalanced annotation
    5)Hystrix Circuit Breaker:
    Hystrix can catch all problems of underlying services and process a fallback plan. The circuit breaker means that if a system
    call resuls in an error, the circuit breaker is opened and does not allow any calls to pass through. The steps of using 
    hystrix is add hystrix dependencies -> add @EnableCircuitBreaker -> write the restTemplate method to call another service
    and fallback method -> add @HystrixCommand(fallback = "fallback_method")
```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```
```
@SpringBootApplication
@EnableCircuitBreaker
public class VaccinationCenterApplication{

}
@GetMapping("/id/{id}")
@HystrixCommand(fallbackMethod = "handleCitizenDownTime")
public ResponseEntity<RequiredResponse> getAllDataBasedonCenterId(@PathVariable Integer id){

}
public ResponseEntity<RequiredResponse> handleCitizenDownTime(@PathVariable Integer id){
}
```
    6)Kafka: There are message broker/agent, producer and consumer. The producer sent message to kafka. And te consumer can get 
    message from it. In this way, clients/servers can communicate with each other asynchronously.
    7)Docker: It provides a container environment, in which any application can be hosted. This is accomplished by tightly 
    packaging both the application and the dependencies required to support it. These packaged products are referred to as
    Containers, and since Docker is used to doing that, they are called Docker containers. Docker, in essence, allows you to 
    containerize your microservices and manage these microservices more easily.

##3. What are Resilience patterns? What is circuit breaker?
####Answer:
    Resiliency patterns are a type of service architecture that help to prevent cascading failures and to preserve functionality 
    in the event of service failure.The resilience patterns include time out, fast fail, bulkhead, and circuit breaker. The circuit 
    breaker is that if a system results in an error, the circuit breaker will be opened, and does not allow any calls to pass through. 

##4. Read this article, then list the important questions, then write your answers
      a. https://www.interviewbit.com/microservices-interview-questions/#main-features-of-microservices
####Answer:
    1)Write main features of Microservices
      a.Decoupling: Within a system, services are largely decoupled. The application as a whole can therefore be easily 
        constructed, altered, and scalable.
      b.Componentization: Microservices are viewed as independent components that can easily be exchanged or upgraded
      c.Business Capabilities: Microservices are relatively simple and only focus on one service
      d.Team autonomy: Each developer works independently of each other, allowing for a faster project timeline
      e.Continuous Delivery: Enables frequent so􀈅ware releases through systematic automation of so􀈅ware development, 
        testing, and approval
      f.Responsibility: Microservices are not focused on applications as projects. Rather, they see applications as products 
        they are responsible for
      g.Decentralized Governance: Choosing the right tool according to the job is the goal. Developers can choose the best 
        tools to solve their problems
      h.Agility: Microservices facilitate agile development. It is possible to create new features quickly and discard them again at any time.  
    2)What are the benefits and drawbacks of Microservices?
    Benefits:
        a.Self-contained, and independent deployment module.
        b.Independently managed services.
        c.In order to improve performance, the demand service can be deployed on multiple servers.
        d.It is easier to test and has fewer dependencies.
        e.A greater degree of scalability and agility.
        f.Simplicity in debugging & maintenance.
        g.Better communication between developers and business users.
        h.Development teams of a smaller size.
    Drawbacks:
        a.Due to the complexity of the architecture, testing and monitoring are more difficult.
        b.Lacks the proper corporate culture for it to work.
        c.Pre-planning is essential.
        d.Complex development.
        e.Requires a cultural shi􀈅.
        f.Expensive compared to monoliths.
        g.Security implications.
        h.Maintaining the network is more difficult.
    3)Write difference between Monolithic, SOA and Microservices Architecture.
        a.Monolithic Architecture: All the software components of an application are bundled together tightly. It is usually 
        built as one large system and is one code-base.
        b.SOA (Service-Oriented Architecture): It is a group of services interacting or communicating with each other. Depending 
        on the nature of the communication, it can be simple data exchange or it could involve several services coordinating some activity.
        c.Microservice Architecture: It involves structuring an application in the form of a cluster of small, autonomous services 
        modeled around a business domain. The functional modules can be deployed independently, are scalable, are aimed at
        achieving specific business goals, and communicate with each other over standard protocols.
    4)Explain how independent microservices communicate with each other.
        a.using HTTP/REST with JSON or binary protocol for request-response
        b.using Websockets for streaming.
        c.using a broker or server program that uses advanced routing algorithms.
        In addition, RabbitMQ, Nats, Kafka can be used as message brokers. Each of them is built to handle a particular message semantic. 
        For example, Backend as a Service like Space Cloud can be used to automate the entire backend.
    5)Write the fundamental characteristics of Microservice Design.
        a.Based on Business Capabilities: Services are divided and organized around business capabilities.
        b.Products not projects: A product should belong to the team that handles it.
        c.Essential messaging frameworks: Rely on functional messaging frameworks: Eliminate centralized service buses by 
        embracing the concept of decentralization.
        d.Decentralized Governance: The development teams are accountable for all aspects of the software they produce.

##5. how to do load balance in microservice? Write a long Summary by yourself.
      a. https://www.geeksforgeeks.org/load-balancer-system-design-interview-question/
      b. https://www.fullstack.cafe/blog/load-balancing-interview-questions
####Answer:
    1)When we design and do load balance in microservice, we need to consider many factors.
        a.load balancing algorithm which decides how to distribute input requests to the servers, like round-bin, least connections,
        and IP harsh.
        b.the way to do the health check, which ensures that every server works well and only healthy server can receive 
        the inputing requests.
        c.the persistence of session, which ensures that subsequent requests from the same user can be directed to the same server.
        d.how to implement scalability and high availability.
        e.how the designed load balance impact the whole performance of the application, such as the latency and throughput 
        of incoming requests.
    2)There are three types of load balancing according to the way load balancer is placed:
        a.Software Load Balancers in Clients: The load balancing logic is in the application client side.
        Advantages: this way is one of the cheapest way to implement load balancing.
        Disadvantages: it is not quite flexible.
        b.Software Load Balancers in Services: In this way, load balancer is the pieces of software which receive incoming 
        requests and redirect these requests according to some specific rules.
        Advantages: cheap and flexible. Because the load balancer can be installed on any device in this way.
        c.Hardware Load Balancer: In this way, physical applicance such as Layer 4-7 Routers are imported to distribute the 
        traffic across the cluster of network servers.
        Advantages: Due to health checks, each server can respond properly. And it can handle a varity of incoming requests.
        Disadvantages: Expensive and limited flexibility.
    3)We can choose a specific algorithm from a varity of load balancing algorithm according to the configuration to let requests
    be directed to the desired servers.
        a.Least Connection Method: direct the traffic to the server with the fewest active connections.
        Situation: there are a large number of persistent connections in the traffic but distributed unevenly between servers.
        b.Least Response Time Method: direct the request to the server with the fewest active connections, the fewest send requests
        and the lowest average response time.
        c.Round Robin Method: direct the request to the first avaliable server, and then moves the server to the bottom of the queue.
        Situation: In a single geographic location, the servers are with the same specification, and there are not a lot of 
        persistent connections.
        d.IP Hash: the request will be direct to the server according to the IP address of the client.
        e.The "Power of Two Choices": The algorithm will choose two servers from the fleet randomly at first, and then choose the 
        one with the fewest active connections.
        Situation: When the number of servers grows and the distribution of selected servers widens, this way is very useful.
        Because it can not only save the cost to check all servers, but also make a better choice than purly random decision.

##6. Udemy: Theory + CLI
####Answer:
      Completed.