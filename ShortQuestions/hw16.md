# Homework 6

### 1. List all of the new learned annotations to your annotations.md
### 2. what is selenium(YouTube)?
Selenium is an open-source tool used for automating web browsers. Selenium tests are automated tests that use the Selenium framework to interact with web pages, simulate user actions, and verify the behavior of web applications.

With Selenium, testers can write scripts in various programming languages such as Java, Python, C#, Ruby, etc., and use them to test web applications across different browsers and operating systems. Selenium provides a suite of tools and libraries that can be used for various types of testing, such as functional testing, regression testing, and acceptance testing.

Some examples of Selenium tests include:

Testing the login functionality of a web application by entering valid and invalid credentials and verifying the response.
Testing the functionality of a search bar by entering different search queries and verifying the results.
Testing the navigation of a web application by clicking on links and verifying that the correct pages are loaded.
Testing the behavior of a web form by entering data and verifying that it is saved correctly.
Selenium tests can be executed either locally or remotely, and they can be integrated with other testing frameworks such as TestNG, JUnit, or NUnit to provide advanced reporting and test management capabilities. Overall, Selenium is a powerful tool for automating web testing and ensuring the quality and reliability of web applications.

### 3. what is cucumber(youtuebe)?
Cucumber is a tool for behavior-driven development (BDD) that allows developers and stakeholders to define and automate tests in plain language. Cucumber tests are written in a specific syntax called Gherkin, which allows for collaboration between technical and non-technical stakeholders.

### 4. what is JMeter(youtube)?
Apache JMeter is an open-source tool designed to perform load testing, performance testing, and functional testing on different types of applications such as web, databases, and APIs. It allows users to simulate various types of traffic and test the performance and scalability of their applications under different conditions.

JMeter has a graphical user interface (GUI) that allows users to create and run test plans. Test plans are made up of different elements such as thread groups, samplers, and listeners. Thread groups represent virtual users or threads that simulate real user behavior. Samplers are the elements that generate requests to the server being tested. Listeners collect the data generated by the test and display it in various formats such as graphs, tables, or charts.

Some of the key features of JMeter include:

Load and performance testing: JMeter can simulate a large number of users accessing a server or group of servers, and measure the performance of the application under varying levels of load.

Protocols and technologies: JMeter supports a wide range of protocols and technologies, including HTTP, HTTPS, FTP, SOAP, REST, JDBC, and JMS.

Distributed testing: JMeter can run tests on multiple machines simultaneously, allowing users to perform distributed testing.

Extensibility: JMeter can be extended with plugins and scripts to add custom functionality.

Overall, JMeter is a powerful tool for load and performance testing that can help users ensure that their applications can handle the expected load and perform optimally under different conditions.

### 5. what is unit-test?
Unit testing is a software testing technique in which individual units or components of a software application are tested in isolation to ensure that they work as expected. A unit is the smallest testable part of an application, typically a single function, method, or class.

Unit tests are automated tests that verify the behavior of individual units or components of the software application. The goal of unit testing is to detect and isolate defects early in the development cycle, when they are less costly to fix.

Unit tests are typically written by developers using testing frameworks such as JUnit, NUnit, or pytest. The test code is usually written in the same programming language as the application being tested and is integrated with the development process.

Unit tests are designed to be fast, repeatable, and easy to maintain. They should test a single unit or component in isolation from other units or components, and should not depend on external resources such as databases or web services.

### 6. What is the lifecircle of Junit?
The lifecycle of JUnit involves the following steps:

Test class creation: A test class is created to write and execute JUnit tests.
Test method creation: Test methods are created inside the test class to test individual units or components of the software application.
Annotation usage: JUnit provides annotations such as @Test, @Before, @After, @BeforeClass, and @AfterClass that are used to mark test methods and define setup and teardown methods.
Test execution: JUnit executes the tests in the order defined in the test class and reports the results.
Test report generation: JUnit generates a report of the test results, including the number of tests run, the number of tests passed, and the number of tests failed.
Test failure analysis: If a test fails, JUnit provides detailed information about the failure, including the line number and stack trace.
Test debugging: Developers can use the test failure information to debug and fix the defects in the software application.
Test maintenance: Developers can maintain and update the JUnit tests as the software application evolves and changes over time.

Overall, the JUnit lifecycle is a continuous process of writing, executing, and maintaining tests to ensure the quality and reliability of software applications.

### 7. Is @BeforeAll method should be Class level(static)?
Yes, the @BeforeAll method in JUnit should be defined as a static method at the class level. This annotation is used to indicate that a method should be executed once before any tests in the class are run.

### 8. What is Mockito? and what is its limitations?
Mockito is a popular Java mocking framework that is used to create mock objects in unit tests. A mock object is a test double that is used to simulate the behavior of a real object, allowing developers to test their code in isolation.

Mockito provides a simple and easy-to-use API for creating mock objects and defining their behavior. With Mockito, developers can easily create mock objects for interfaces, abstract classes, and concrete classes, and can define the behavior of the mock objects using simple method calls.

Mockito has some limitations, including:

Limited support for final classes and methods: Mockito cannot mock final classes or methods, which can be a limitation in some scenarios.
Limited support for static methods: Mockito cannot mock static methods, which can be a limitation in some scenarios.
Limited support for private methods: Mockito cannot mock private methods, which can be a limitation in some scenarios.
Limited support for constructors: Mockito cannot mock constructors, which can be a limitation in some scenarios.

### 9. What is @Mock and what is @InjectMocks?
@Mock and @InjectMocks are annotations provided by the Mockito mocking framework to create and inject mock objects into test classes.

@Mock annotation is used to create a mock object of a class or an interface. When the test class is executed, Mockito will automatically create an instance of the mock object and inject it into the test class. 

@InjectMocks annotation is used to inject mock objects created using the @Mock annotation into the class under test. 

### 10. What is the stubbing?
Stubbing is a technique used in unit testing to define the behavior of a method or a function call in a test double, such as a mock object or a stub object.

When testing a class that has dependencies, it's often necessary to create mock or stub objects to isolate the code being tested from its dependencies. These mock or stub objects can be used to simulate the behavior of the real objects and provide consistent, predictable behavior during testing.

Stubbing involves defining the expected behavior of a method or function call in a test double. For example, if a method calculateTotal depends on a method getPrice to retrieve prices, we can use stubbing to define the behavior of getPrice for the purpose of testing calculateTotal.

### 11. what is Mockito ArgumentMatchers
Mockito ArgumentMatchers is a feature of the Mockito framework, which is a popular Java testing framework used for unit testing. ArgumentMatchers provide a convenient way to specify the expected arguments of a method call when setting up a mock object.

When using Mockito, you can create a mock object that simulates the behavior of a real object. You can then set up expectations on this mock object by specifying the expected behavior of its methods, including the expected arguments and return values.

The ArgumentMatchers class provides a set of static methods that allow you to specify the expected arguments for a method call on a mock object. For example, you can use the any() method to indicate that any argument of the appropriate type is acceptable, or you can use the eq() method to specify a specific value for an argument.

### 12. what is Hamcrest Matchers
Hamcrest Matchers is a library of matchers for writing more expressive and readable unit tests in Java. The library provides a set of assertions that allow you to write tests that are easier to read, more precise, and more expressive than traditional JUnit assertions.

Hamcrest Matchers are used in combination with testing frameworks such as JUnit and Mockito to write test cases with more readable assertions. The matchers provide a fluent and readable way to specify expected outcomes of a test. The library provides a wide range of matchers, including:

Comparison matchers such as equalTo, greaterThan, lessThan, closeTo, etc.
Logical matchers such as allOf, anyOf, not, etc.
Text matchers such as containsString, startsWith, endsWith, matchesRegex, etc.
Collection matchers such as hasItem, hasItems, containsInAnyOrder, etc.

### 13. do you know @spy? what is difference between @spy and @Mock?
In Mockito, @Mock is used to create a mock object, while @Spy is used to create a partial mock object.

A mock object is a test double that simulates the behavior of a real object. It allows you to test the behavior of a specific method without needing to set up the entire object. When you create a mock object using @Mock, you are creating a complete simulation of the object, and any method that is not explicitly defined will have a default behavior of doing nothing or returning null.

On the other hand, a partial mock object is a test double that simulates the behavior of a real object, but still allows you to call real methods on the object. When you create a partial mock object using @Spy, you are creating an object that is partially mocked and partially real. You can define the behavior of certain methods explicitly, while allowing other methods to behave as they do in the real object.

### 14. briefly reading this articles
### a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse-ide
### b. https://www.javatpoint.com/junit-tutorial
### c. https://www.javatpoint.com/testng-tutorial
### d. https://www.javatpoint.com/jmeter-tutorial
### 15. Add unit test for CommentServiceImpl, the coverage should be 100%.