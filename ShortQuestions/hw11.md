# Homework 11

## Part1 exception-validation

### 1. List all of the annotations you learned from class and homework to annotaitons.md

### 2. what is the @configuration and @bean?
Spring @Configuration annotation allows us to use annotations for dependency injection. 


### 3. How do you handle the exception in Spring?
When something goes wrong with your application, the server displays an exception page defining the type of exception, the server-generated exception page is not user-friendly. Spring MVC provides exception handling for your web application to make sure you are sending your own exception page instead of the server-generated exception to the user. The @ExceptionHandler annotation is used to detect certain runtime exceptions and send responses according to the exception. In this article we’ll Spring Mvc project to show how to intercept and define exceptions, we’ll look at how to define method level as well as the class level exception.

### 4. How do you do the validations in Spring?
In Spring, you can perform input validations using the javax.validation API, which is a standard part of Java. Here are the basic steps to perform input validation in Spring:

1. Add the javax.validation and hibernate-validator dependencies to your project. You can use a build tool like Maven or Gradle to manage your dependencies.
2. Annotate the fields in your model classes with validation annotations. 
3. In your controller method, add an @Valid annotation before the model object that you want to validate. This will trigger the validation process.
4. If the input is invalid, Spring will throw a MethodArgumentNotValidException. You can handle this exception in a number of ways, such as returning a custom error response.


### 5. What is the actuator?
Spring Boot Actuator is a feature of the Spring Boot framework that provides additional endpoints for your application, which can be used to monitor and manage your application at runtime. These endpoints expose information about your application, such as health status, performance metrics, and environment details. The Actuator endpoints are implemented using Spring MVC and can be accessed through HTTP requests or JMX (Java Management Extensions) clients.

Some examples of Actuator endpoints are:

/actuator/health: Returns the health status of the application.
/actuator/info: Returns general information about the application.
/actuator/metrics: Returns various metrics of the application, such as memory usage, request count, etc.
/actuator/env: Returns the environment details of the application, such as system properties and environment variables.
Actuator endpoints can also be customized or extended to provide additional information or functionality specific to your application.

Actuator is a very useful feature for monitoring and managing your application in production environments, as it provides valuable information about the application's health and performance, without the need for additional tools or libraries.

## Part2 spring

### 1. List all of the annotations you learned from class and homework to annotaitons.md


### 2. What is Spring and Springboot? What is the benfits of using Srpingboot?
Spring is a lightweight open-source Java development framework. It provides a comprehensive programming and configuration model for developing enterprise level Java applications. It aims to simplify enterprise Java development and helps developers build applications more effectively and efficiently. Spring focuses on several areas of application development and provides a wide range of features.

Spring Boot is an extension of Spring, which eliminates the boilerplate configurations required for setting up a Spring application. Featuring default codes and annotation based configuration, Spring Boot enables a faster and more efficient development ecosystem. Since Spring Boot is built on top of Spring, it offers all the features and benefits of Spring. Spring Boot aims to reduce code length and provides developers with the easiest way to build an application.

Spring vs. Spring Boot
Spring is the most popular application development framework in Java. However, over the past few years, Spring has become increasingly complex because of added functionalities. Starting a new project usually requires going through a lengthy process and takes a lot of time.

To avoid starting from scratch and to save time, Spring Boot was introduced. Spring Boot uses Spring as its foundation layer and allows developers to build a standalone application with none or minimal configuration. It is targeted specifically towards building web applications and microservices.

### 3. What is IOC and What is DI?
In software engineering, inversion of control (IoC) is a design pattern in which custom-written portions of a computer program receive the flow of control from a generic framework. A software architecture with this design inverts control as compared to traditional procedural programming: in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic tasks, but with inversion of control, it is the framework that calls into the custom, or task-specific, code.

In software engineering, dependency injection is a design pattern in which an object or function receives other objects or functions that it depends on. A form of inversion of control, dependency injection aims to separate the concerns of constructing objects and using them, leading to loosely coupled programs.The pattern ensures that an object or function which wants to use a given service should not have to know how to construct those services. Instead, the receiving 'client' (object or function) is provided with its dependencies by external code (an 'injector'), which it is not aware of

### 4. What is @CompnonentScan?
@ComponentScan is used along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.

### 5. How to define which package spring need to scan in xml and annotaiton?
In Spring, you can use XML-based configuration to define which packages should be scanned for Spring-managed components. You can achieve this by defining a `context:component-scan` element in your XML configuration file.

The context:component-scan element is part of the Spring Context namespace and is used to enable component scanning in a Spring application. You can specify the base package(s) to be scanned using the "base-package" attribute.

### 6. What is @SpringbootApplication?
Spring Boot @SpringBootApplication annotation is used to mark a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning. It’s same as declaring a class with @Configuration, @EnableAutoConfiguration and @ComponentScan annotations.

### 7. How many ways we can define a bean?
There are 3 ways to define a bean. 
1. Creating Bean Inside an XML Configuration File (beans.xml)
2. Using @Component Annotation
3. Using @Bean Annotation

### 8. What is default bean name for @Component and @Bean?
In Spring, the default bean name for a component annotated with @Component is the uncapitalized, fully qualified class name. For example, if you have a class named "MyComponent" in the package "com.example", the default bean name would be "myComponent".

When using the @Bean annotation to define a bean in a configuration class, the default bean name is the name of the bean definition method. For example, if you have a @Bean method named "myBean" in a configuration class, the default bean name would be "myBean".

It's worth noting that you can explicitly specify a bean name for a component or a @Bean method using the "value" attribute of the @Component or @Bean annotation. If you do not specify a value, Spring will use the default bean name.

### 9. What is the difference between @component and @service,@repository?
In Spring, all four annotations - @Component, @Controller, @Service, and @Repository - are used to indicate that a class is a Spring-managed component. However, they have different semantics and are typically used for different types of classes.

@Component: The @Component annotation is the most general-purpose annotation for Spring-managed components. It can be used to annotate any class that should be managed by Spring, regardless of its function or role in the application.
@Controller: The @Controller annotation is typically used to indicate that a class serves as a web controller in a Spring MVC-based web application. It handles incoming HTTP requests and returns an appropriate HTTP response. Controllers typically handle user input and orchestrate the flow of data between the view and the model.
@Service: The @Service annotation is typically used to indicate that a class provides a business service or some other type of service layer functionality. It is commonly used in the service layer of a web application. Services typically implement business logic and coordinate the work of multiple components.
@Repository: The @Repository annotation is typically used to indicate that a class provides data access and persistence functionality, such as database access. It is commonly used in the data access layer of a web application. Repositories typically encapsulate the logic for reading and writing data to and from a data store.
While all four annotations have the same effect on the managed component, using the appropriate annotation can help convey the purpose and role of the component more clearly, and can make the code easier to read and understand.

For example, if you have a class that serves as a web controller, it would be more appropriate to annotate it with @Controller than with @Service, @Repository, or @Component. Similarly, if you have a class that provides business logic functionality, it would be more appropriate to annotate it with @Service than with @Controller, @Repository, or @Component.

In summary, while all four annotations are used to indicate that a class is a Spring-managed component, they have different semantics and are typically used for different types of classes in a Spring application.

### 10. How many annotaitons we can use to inject the bean?
In Spring, there are several annotations that can be used to inject beans into other components:

@Autowired: The @Autowired annotation is used to inject a bean into a dependent component automatically. Spring will look for a matching bean in the context and inject it into the component.
@Qualifier: The @Qualifier annotation is used in conjunction with @Autowired to specify which bean to inject when there are multiple beans of the same type in the context.
@Resource: The @Resource annotation is a Java EE standard annotation that can be used to inject a bean into a dependent component. It works in a similar way to @Autowired, but can also be used to inject non-Spring beans.
@Value: The @Value annotation is used to inject a value, such as a property or a configuration setting, into a component.
@Inject: The @Inject annotation is another Java EE standard annotation that can be used to inject a bean into a dependent component. It works in a similar way to @Autowired, but provides more fine-grained control over injection.

All of these annotations can be used to inject beans into other components in a Spring application, and the choice of which one to use depends on the specific requirements of the application. In general, @Autowired is the most commonly used annotation for dependency injection in Spring.

### 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?


### 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.
Use the @Primary to mark the bean as primary. If you do not specify a primary bean and there are multiple beans of the same type, Spring will throw an exception at startup, as it is not clear which bean to use for injection. To resolve this, you can use @Qualifier or @Resource to specify the bean to inject.

### 13. What is the difference between BeanFactory and ApplicationContext in Spring?
BeanFactory and ApplicationContext are both interfaces in Spring that provide bean management and dependency injection capabilities, but they differ in their features and capabilities.

BeanFactory is the basic interface for the Spring IoC container, and it provides the fundamental functionality for managing beans. It is a low-level interface that defines the basic contract for managing and accessing beans, and it is typically used in resource-constrained environments or when low-level bean management is required. BeanFactory provides lazy loading of beans, so it only creates beans when they are requested for the first time. BeanFactory is more lightweight than ApplicationContext, as it only loads and initializes beans when they are actually used.

ApplicationContext, on the other hand, is a more feature-rich and high-level interface that extends the functionality of BeanFactory. It provides all the features of BeanFactory and adds additional capabilities, such as support for internationalization, events, message sources, and application contexts hierarchies. ApplicationContext eagerly loads all beans at startup, so they are ready to be used when needed. ApplicationContext is typically used in larger and more complex applications that require a wide range of features beyond basic bean management.

In summary, the main differences between BeanFactory and ApplicationContext are:

BeanFactory is a lightweight, low-level interface for managing beans, while ApplicationContext is a more feature-rich and high-level interface that extends the functionality of BeanFactory.
BeanFactory provides lazy loading of beans, while ApplicationContext eagerly loads all beans at startup.
BeanFactory is typically used in resource-constrained environments or when low-level bean management is required, while ApplicationContext is typically used in larger and more complex applications that require a wide range of features beyond basic bean management.
Overall, the choice between BeanFactory and ApplicationContext depends on the specific requirements of the application. If you need a lightweight solution with low-level bean management, BeanFactory may be the better choice. If you need a more feature-rich and high-level solution with additional capabilities, ApplicationContext may be the better choice.

### 14. What is the Scope of a Bean? and list the examples for each scope.
In Spring, the scope of a bean defines the lifecycle and visibility of the bean instance. The scope of a bean can be specified using the @Scope annotation or the "scope" attribute in XML configuration. The following are the different scopes available in Spring:

Singleton: The Singleton scope creates a single instance of the bean for the entire application context. This is the default scope of a bean in Spring. Examples of beans that are typically defined as singletons include application configuration objects, utility classes, and DAOs.

Prototype: The Prototype scope creates a new instance of the bean every time it is requested from the application context. Examples of beans that are typically defined as prototypes include request-scoped objects, such as controllers and form-backing objects.

Request: The Request scope creates a new instance of the bean for every HTTP request. The bean instance is destroyed after the request is completed. Examples of beans that are typically defined as request-scoped include controllers and form-backing objects.

Session: The Session scope creates a single instance of the bean for every HTTP session. The bean instance is destroyed when the session expires. Examples of beans that are typically defined as session-scoped include user-specific data and shopping carts.

Overall, the choice of scope depends on the specific requirements of the bean and the application. The default Singleton scope is appropriate for most beans, but other scopes are useful in situations where you need finer control over the lifecycle and visibility of bean instances.

### 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)
In Spring, you can configure a bean with parameters or dependencies in XML using the constructor-arg element. The constructor-arg element specifies the arguments that are passed to the constructor of the bean.