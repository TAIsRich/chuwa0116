#### 1. What is Spring and Springboot? What is the benfits of using Srpingboot?    

Spring is a popular open-source framework for building Java-based enterprise applications. It provides a comprehensive programming and configuration model for modern Java-based enterprise applications, and offers features such as dependency injection, aspect-oriented programming, and support for web frameworks like Spring MVC and Spring WebFlux.      

Spring Boot is a framework that builds on top of the Spring framework to make it easier to build and deploy Spring-based applications. It provides a set of preconfigured and opinionated defaults for many of the most common aspects of Spring-based applications, such as auto-configuration of the Spring application context, simplified dependency management, and the ability to create stand-alone applications with embedded web servers.    

Some of the key benefits of using Spring Boot include:    
1. Rapid Application Development: Spring Boot makes it easy to get up and running quickly by providing a set of preconfigured defaults, reducing the need for developers to spend time on boilerplate code.     
2. Easy Configuration: Spring Boot provides a powerful and flexible way to configure Spring applications using properties files, YAML files, environment variables, and other sources.     
3. Built-in Web Server: Spring Boot includes a number of embedded web servers, which makes it easy to create and deploy standalone applications without needing to configure an external web server.
4. Production-ready: Spring Boot provides a range of tools and features that are designed to make it easy to build and deploy production-grade applications, including health checks, metrics, and a powerful actuator API.     
5. Community Support: Spring Boot has a large and active community of developers, which means that there are plenty of resources available for developers who are looking for help or advice.     

#### 2. What is IOC and What is DI?    

n the context of Spring and other frameworks, "IOC" stands for Inversion of Control, and "DI" stands for Dependency Injection. These are closely related concepts that are used to implement loosely coupled and maintainable software architectures.      

In traditional programming, an object is responsible for creating and managing its own dependencies. This can lead to tightly coupled and brittle code, where changes to one object can have unexpected and far-reaching effects on other parts of the application.      

In contrast, with IOC and DI, the responsibility for creating and managing object dependencies is moved outside of the object itself, and handled by an external framework or container. This allows objects to be more loosely coupled, and makes it easier to make changes to the application without affecting other parts of the system.      

In practical terms, DI is a technique for providing the dependencies required by an object as constructor parameters or method arguments, rather than having the object create or look up its own dependencies. This allows the dependencies to be easily swapped out or mocked for testing, and makes it easier to reason about the behavior of the object.      

The IOC container is responsible for managing the lifetime and configuration of the objects in the application, including creating and injecting their dependencies. This allows objects to be created and destroyed dynamically at runtime, and makes it possible to write more flexible and maintainable code.      

Spring's IOC container is called the Application Context, and it provides a rich set of features for managing object dependencies and configuration, including support for annotations, XML configuration, and more.      

#### 3. What is @CompnonentScan?      

@ComponentScan is an annotation used in Spring to specify the base packages for Spring to scan for components such as @Component, @Service, @Repository, and @Controller annotations.      

When Spring scans these packages, it will automatically detect the classes that are annotated with these annotations and register them as Spring beans in the application context. This makes it easier to manage object dependencies and allows you to take advantage of Spring's powerful dependency injection capabilities.     

Here's an example of how to use @ComponentScan:     
```
@Configuration
@ComponentScan(basePackages = {"com.example.app.services", "com.example.app.controllers"})
public class MyAppConfig {
   // other bean definitions
}
```
In this example, we are using @ComponentScan to scan the com.example.app.services and com.example.app.controllers packages for Spring components. Any classes annotated with @Component, @Service, @Repository, or @Controller within these packages will be automatically registered as Spring beans.     

You can also use other attributes of @ComponentScan to further refine the search for components, such as excludeFilters to exclude certain classes, and includeFilters to include classes that may not be annotated with Spring's component annotations.     

It's important to note that @ComponentScan is not always required, as you can also define beans manually using other annotations such as @Bean or XML configuration. However, @ComponentScan can be a convenient way to automatically register many beans at once, and can help reduce the amount of boilerplate code required to set up a Spring application.     

#### 4. How to define which package spring need to scan in xml and annotation?     

In Spring, you can specify the package(s) that Spring should scan for components using both XML configuration and annotations.     

Using XML Configuration:     

To define which packages Spring should scan for components in XML configuration, you can use the <context:component-scan> element. Here's an example:     
```
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <context:component-scan base-package="com.example.app" />
    
    <!-- other bean definitions -->

</beans>
```
In this example, we are telling Spring to scan the com.example.app package for components using the <context:component-scan> element. This will register any classes annotated with Spring's component annotations such as @Component, @Service, @Repository, and @Controller.      

Using Annotations:     
To define which packages Spring should scan for components using annotations, you can use the @ComponentScan annotation on a configuration class. Here's an example:     
```
@Configuration
@ComponentScan("com.example.app")
public class MyAppConfig {
    // other bean definitions
}
```

In this example, we are telling Spring to scan the com.example.app package for components using the @ComponentScan annotation on the MyAppConfig class. This will register any classes annotated with Spring's component annotations such as @Component, @Service, @Repository, and @Controller.    

You can also use the basePackages attribute of @ComponentScan to specify multiple packages to scan, and use other attributes like excludeFilters and includeFilters to further customize the component scanning process.     
#### 5. What is @SpringbootApplication?     

@SpringBootApplication is a meta-annotation in Spring Boot that combines several other annotations (@Configuration, @EnableAutoConfiguration, and @ComponentScan) commonly used in Spring applications.      

The @SpringBootApplication annotation is typically used to mark the main class of a Spring Boot application, and is usually placed in the root package of the application. Here's an example:      

```
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
```
In this example, the @SpringBootApplication annotation is applied to the MyApp class, which is the main class of the Spring Boot application. The main method uses the SpringApplication.run method to start the application.    

The @SpringBootApplication annotation enables the following features:     

1. @Configuration: Allows the class to define Spring configuration beans.    
2. @EnableAutoConfiguration: Enables Spring Boot's auto-configuration mechanism, which automatically configures the application based on its classpath and other settings.    
3. @ComponentScan: Scans the package and its sub-packages to find Spring components, such as @Component, @Service, @Repository, and @Controller annotations.    

By combining these three annotations, @SpringBootApplication provides a convenient and powerful way to start a Spring Boot application with minimal configuration. It enables Spring Boot's auto-configuration mechanism, which can greatly simplify the setup and configuration of a Spring application, and provides a good starting point for building modern, production-ready applications.      

#### 6. How many ways wo can define a bean?    

In Spring, there are several ways to define a bean:       

1. Using XML configuration: Beans can be defined using XML configuration files. The <bean> element is used to define a bean, and the class attribute is used to specify the class of the bean.      

2. Using Java configuration: Beans can be defined using Java configuration classes that are annotated with @Configuration. The @Bean annotation is used to define a method that returns an instance of a bean.      

3. Using component scanning: Beans can be defined using Spring's component scanning mechanism, which automatically detects and registers classes that are annotated with Spring's component annotations (@Component, @Service, @Repository, and @Controller).       

4. Using factory methods: Beans can be defined using factory methods, which are static methods that return an instance of a bean. The @Bean annotation can be used to define a factory method.      

5. Using annotations: Beans can be defined using other Spring annotations, such as @Value for injecting values from properties files or environment variables, or @Autowired for injecting dependencies.       

Each of these methods has its own advantages and disadvantages, and the choice of which method to use will depend on the specific requirements and constraints of the application. For example, XML configuration is a good choice for large and complex applications that require fine-grained control over the configuration, while component scanning is a good choice for smaller and simpler applications that require less boilerplate code.      
#### 7. What is default bean name for @Component and @Bean?       

In Spring, the default bean name for a bean defined using @Component or @Bean depends on the name of the class or method being annotated.     

For a class annotated with @Component, the default bean name is the uncapitalized non-qualified class name. For example, if we have a class named MyService, the default bean name would be myService.      

Here's an example:      
```
@Component
public class MyService {
    // ...
}
```
In this example, the default bean name for the MyService class is myService.      

For a method annotated with @Bean, the default bean name is the method name. For example, if we have a method named myBean that returns an instance of MyBean, the default bean name would be myBean.      

Here's an example:      
```
@Configuration
public class MyAppConfig {
    @Bean
    public MyBean myBean() {
        MyBean bean = new MyBean();
        // ...
        return bean;
    }
}
```
In this example, the default bean name for the myBean method is myBean.    

It's important to note that you can also explicitly specify a bean name using the value attribute of the @Component or @Bean annotations. For example:     
```
@Component("myCustomName")
public class MyService {
    // ...
}

@Configuration
public class MyAppConfig {
    @Bean("myCustomName")
    public MyBean myBean() {
        MyBean bean = new MyBean();
        // ...
        return bean;
    }
}
```
In these examples, we are explicitly setting the bean name to myCustomName for the MyService class and the myBean method, respectively.    
#### 8. What is the difference between @component and @service, @repository?     

In the context of Spring Framework, @Component, @Service, and @Repository are all annotations that can be used to declare a class as a Spring bean.     
@Component is the most generic annotation and can be used to mark any class as a Spring bean. It is typically used to mark classes that are not persistence related or business logic related, such as utility classes or helper classes.     

@Service is a specialization of @Component and is used to mark classes that perform a service, such as business logic or application services. Typically, @Service classes are used to provide higher level business logic and orchestrate the data access layer.    

@Repository is also a specialization of @Component and is used to mark classes that provide data access. Typically, @Repository classes interact with a persistence layer, such as a database or a file system.    

All three annotations can be used interchangeably to declare a class as a Spring bean, but using the appropriate annotation can help to make the code more organized and expressive. Additionally, Spring provides some special behavior and functionality for each annotation, for example, @Repository classes have some extra exception translation features.     

#### 9. How many annotaitons we can use to inject the bean?     

There are several annotations in Spring Framework that can be used to inject beans into other objects:      

1. @Autowired: This annotation can be used to inject a bean by type. Spring will look for a bean that matches the type of the field, constructor parameter, or method parameter that the annotation is applied to.     

2. @Resource: This annotation can be used to inject a bean by name. Spring will look for a bean with a name that matches the value of the annotation.     

3. @Inject: This is a standard Java annotation that can be used to inject a bean by type, similar to @Autowired. It is part of the Java Dependency Injection specification (JSR 330), which Spring supports.     

4. @Value: This annotation can be used to inject a value into a bean, such as a string, a number, or a boolean.    

5. @Qualifier: This annotation can be used in conjunction with @Autowired or @Inject to specify which bean to inject when there are multiple beans of the same type.     

#### 10. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?      

1. Constructor Injection: In this approach, dependencies are provided to the class through its constructor. The constructor takes one or more dependencies as parameters, and Spring injects the appropriate beans when creating an instance of the class. Constructor injection is the recommended approach because it ensures that all required dependencies are provided when creating an object, and the object is immutable once created.     

2. Setter Injection: In this approach, dependencies are provided to the class through setter methods. The class defines a set of setter methods, each of which takes a single dependency as a parameter. Spring injects the appropriate beans by calling the setter methods after creating an instance of the class. Setter injection is easier to implement, but it can lead to objects being in an inconsistent state if some dependencies are not set.     

3. Field Injection: In this approach, dependencies are provided to the class through public fields. The class defines a set of public fields, each of which is annotated with the @Autowired or @Inject annotation. Spring injects the appropriate beans by setting the values of the fields after creating an instance of the class. Field injection is the easiest to use, but it can make the code less testable and can lead to objects being in an inconsistent state if some dependencies are not set.      

Constructor injection is generally considered the best approach because it ensures that all required dependencies are provided when creating an object, and the object is immutable once created. It also makes it easier to test the object, because the dependencies can be easily provided through the constructor in the test code. Setter injection and field injection can be useful in some cases, such as when working with legacy code or when using a framework that requires them, but they should be used with caution.    

#### 11. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.    

If there are multiple beans of the same type in a Spring application context, you can use the @Primary annotation to mark one of them as the primary bean for that type. The primary bean will be used by default when injecting the type into other beans, unless a specific bean is requested by name or using the @Qualifier annotation.     

Here is an example of how to use the @Primary annotation to mark a bean as the primary bean for its type:      
```
@Service
@Primary
public class PrimaryService implements MyService {
    // ...
}
```
In this example, the @Primary annotation is used to mark the PrimaryService as the primary bean for the MyService type. When injecting the MyService type into other beans, Spring will use the PrimaryService bean by default.     

If no primary bean is specified, Spring will use the last bean defined for the type that was added to the application context. If multiple beans of the same type are defined, but none are marked as primary, you can use the @Qualifier annotation to specify which bean to inject. The @Qualifier annotation is applied to the field, constructor parameter, or method parameter that requires the bean, and its value should be the name of the bean to inject, like this:       
```
@Service
public class MyServiceClient {
    
    @Autowired
    @Qualifier("specificService")
    private MyService myService;
    
    // ...
}
```
In this example, the @Qualifier annotation is used to specify that the specificService bean should be injected into the myService field, even though there are multiple beans of the MyService type in the application context.      

#### 12. What is the difference between BeanFactory and ApplicationContext in Spring?    

In Spring Framework, BeanFactory and ApplicationContext are two interfaces that provide access to the Spring IoC container, which manages beans and their dependencies.    

BeanFactory is the basic interface for accessing the Spring IoC container. It provides the core functions for managing beans, such as creating, configuring, and retrieving beans. BeanFactory is a low-level interface, and it is not recommended for most applications because it does not provide support for some advanced features of Spring, such as AOP, event handling, and internationalization.    

ApplicationContext is a sub-interface of BeanFactory and provides additional functionality beyond what BeanFactory offers.      

ApplicationContext adds support for advanced features such as AOP, event handling, and internationalization. It also provides support for integration with other Spring frameworks, such as Spring MVC, Spring Security, and Spring Data.         

Here are some of the key differences between BeanFactory and ApplicationContext:      

1. Configuration Loading: BeanFactory lazily loads bean definitions, meaning that it does not read and parse the XML or Java configuration files until a bean is actually requested. ApplicationContext, on the other hand, eagerly loads bean definitions at startup, meaning that it reads and parses the configuration files when the application context is created.     

2. Bean Lifecycle: BeanFactory creates and initializes beans on demand, meaning that it does not create a bean until it is requested. ApplicationContext, on the other hand, creates and initializes all beans when the application context is created.       

3. Advanced Features: BeanFactory provides only basic support for advanced features, such as AOP and event handling. ApplicationContext provides full support for these features, as well as additional features such as internationalization and integration with other Spring frameworks.      

In general, ApplicationContext is recommended for most Spring applications because it provides more functionality and better performance than BeanFactory. However, if you have very limited memory or CPU resources and need to optimize performance, you may consider using BeanFactory instead.        

#### 13. What is the Scope of a Bean? and list the examples for each scope.
 
In Spring Framework, the scope of a bean defines the lifecycle and visibility of the bean instance. There are several scopes available in Spring, each with its own characteristics and use cases. The scope of a bean is defined using the @Scope annotation, which can be applied to a class or a method.       

Here are the most common scopes in Spring and their characteristics:     

1. Singleton: The singleton scope creates a single instance of the bean per application context. This means that every request for the bean will return the same instance. This is the default scope in Spring.      

2. Prototype: The prototype scope creates a new instance of the bean every time it is requested. This means that every request for the bean will return a new instance.     

3. Request: The request scope creates a new instance of the bean for every HTTP request. This means that every HTTP request will have its own instance of the bean. This scope is only valid in a web-aware Spring application.       

4. Session: The session scope creates a new instance of the bean for every HTTP session. This means that every HTTP session will have its own instance of the bean. This scope is only valid in a web-aware Spring application.     

5. Global Session: The global session scope creates a new instance of the bean for every global HTTP session. This means that every global HTTP session will have its own instance of the bean. This scope is only valid in a web-aware Spring application that is deployed in a Portlet environment.     

6. Application: The application scope creates a single instance of the bean for the entire web application. This means that every request for the bean within the same web application will return the same instance. This scope is only valid in a web-aware Spring application.     









