# hw12

## 2. What is Spring and Springboot? What is the benfits of using Srpingboot?

Spring is a lightweight open-source Java development framework. It provides a comprehensive programming and configuration model for developing enterprise level Java applications.

Spring Boot is an extension of Spring, which eliminates the boilerplate configurations required for setting up a Spring application. Featuring default codes and annotation based configuration, Spring Boot enables a faster and more efficient development ecosystem.

## 3. What is IOC and What is DI?

Spring IoC (Inversion of Control) Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. 

Spring Dependency injection is a way to inject the dependency of a framework component by the following ways of spring: Constructor Injection and Setter Injection

## 4. What is @ComponentScan ?

We use the @ComponentScan annotation along with the @Configuration annotation to specify the packages that we want to be scanned.

## 5. How to define which package spring need to scan in xml and annotaiton?

\<context:annotation-config> or \<context:component-scan>

## 6. What is @SpringbootApplication ?

@SpringBootApplication annotation is used to mark a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning.


## 7. How many ways we can define a bean?

annotating your class with the stereotype @Component annotation (or its derivatives)

writing a bean factory method annotated with the @Bean annotation in a custom Java configuration class.

declaring a bean definition in an XML configuration file.


## 8. What is default bean name for @Component and @Bean ?

The default bean name for the @Component and @Bean annotations in Spring is the same as the name of the class with the first letter in lowercase. 

## 9. What is the difference between @component and @service,@repository ?

In Spring Framework, @Component, @Service, and @Repository are all specialized forms of the @Component annotation and can be used interchangeably.

## 10. How many annotaitons we can use to inject the bean?

In Spring, there are several annotations that can be used for dependency injection:

@Autowired: Used to inject dependencies by type. This is the most commonly used annotation for dependency injection.

@Qualifier: Used to disambiguate beans of the same type when multiple beans of the same type are defined in the application context.

@Resource: Used to inject dependencies by name, which can be a bean name or a JNDI name.

@Inject: Similar to @Autowired, but it is part of the Java Dependency Injection (JSR-330) standard.

@Value: Used to inject a specific value, such as a string or a number, into a bean.

@Component: Used to mark a class as a Spring-managed component, which can be automatically injected into other beans.

## 11. Tell me the three types to do dependency injection (How can we inject the beans in Spring) ? Which way is better and why?

Constructor injection: This involves injecting dependencies through a class constructor. The required dependencies are passed as constructor arguments when the object is created. Constructor injection is considered a best practice in Spring, as it ensures that all required dependencies are available when the object is created.

Setter injection: This involves injecting dependencies through setter methods. The required dependencies are set through the corresponding setter methods after the object is created. Setter injection is more flexible than constructor injection, as it allows for optional dependencies and the ability to change dependencies at runtime.

Field injection: This involves injecting dependencies directly into class fields using annotations such as @Autowired. Field injection is the least preferred way of dependency injection, as it can lead to issues with testability and can make it harder to reason about the dependencies of a class.

## 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay

In Spring Framework, we can set one bean as the primary bean for a particular type using the @Primary annotation. When multiple beans of the same type are defined in the application context, the bean marked with @Primary will be given higher precedence over the others.

If there is no primary bean defined for a particular type, Spring will attempt to autowire by type, but it will throw a NoUniqueBeanDefinitionException if multiple beans are found. To resolve this, we can use the @Qualifier annotation to specify which bean to use. The @Qualifier annotation is used in conjunction with @Autowired to specify the bean name or qualifier value of the bean to be injected. 

## 13. What is the difference between BeanFactory and ApplicationContext in Spring?

Lazy loading: BeanFactory provides lazy loading of beans, which means that beans are created only when they are requested for the first time. In contrast, ApplicationContext eagerly creates all beans when the application context is created.

Functionality: ApplicationContext extends BeanFactory and provides additional functionality such as internationalization support, resource loading, and support for aspect-oriented programming.

Scoping: BeanFactory only supports two scopes: singleton and prototype. In contrast, ApplicationContext supports additional scopes such as request, session, and global session.

Integration with Spring Framework: Many of the advanced features in Spring, such as Spring AOP, declarative transactions, and security, require the use of ApplicationContext. These features are not available with BeanFactory.

## 14. What is the Scope of a Bean? and list the examples for each scope

Singleton: This is the default scope for a bean. A single instance of the bean is created, and it is shared across the entire application context.

Prototype: A new instance of the bean is created each time it is requested. This is useful for beans that have state or need to be isolated from other beans.

Request: A new instance of the bean is created for each HTTP request in a web application. This is useful for beans that hold request-specific data.

Session: A new instance of the bean is created for each user session in a web application. This is useful for beans that hold session-specific data.

Global session: A new instance of the bean is created for each global HTTP session in a Portlet context. This is useful for beans that hold global session-specific data.

Application: A single instance of the bean is created per ServletContext in a web application. This is useful for beans that need to be shared across the entire web application.

## 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
  http://www.springframework.org/schema/beans/spring-beans.xsd 
  http://www.springframework.org/schema/context/ 
  http://www.springframework.org/schema/context/spring-context.xsd">
   
  <bean id="operations"  class="com.howtodoinjava.spring.beans.Operations"></bean>
  <bean id="employee"  class="com.howtodoinjava.spring.beans.Employee"></bean>
  <bean id="department"  class="com.howtodoinjava.spring.beans.Department"></bean>
   
</beans> 
```
