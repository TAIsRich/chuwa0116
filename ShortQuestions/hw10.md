## 1.  List all of the annotations you learned from class and homework to annotaitons.md
## 2.  Type the Comment feature for the class project.
    The comment feature for a class project can be implemented by creating a Comment model class that stores the comment text, author, and a reference to the post that the comment belongs to. A CommentController class can then be created to handle the creation, retrieval, and deletion of comments.
## 3.  In postman, call of the APIs in PostController and CommentController.
    In Postman, you can call the APIs in the PostController and CommentController by making HTTP requests to their respective endpoint URLs. You can use the POST method to create a new comment or post, the GET method to retrieve a list of comments or posts, and the DELETE method to delete a comment or post.
## 4.  what is JPA? and what is Hibernate?
    JPA (Java Persistence API) is a Java specification for accessing, persisting, and managing data between Java objects/classes and a relational database. Hibernate is an open-source implementation of JPA that provides a framework for mapping Java classes to database tables, and for providing a mechanism for storing and retrieving Java objects from the database.
## 5.  What is Hiraki? what is the benefits of connection pool?
    Hikari is a high-performance JDBC connection pool that provides a fast and efficient way to manage database connections. The benefits of using a connection pool include improved performance by reusing existing connections and reducing the overhead of establishing new connections, and increased scalability by allowing multiple requests to be processed concurrently.
## 6.  What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.
* @OneToMany: This annotation represents a one-to-many relationship, where one entity is related to many other entities. For example, a Post entity might have many Comment entities.
* @ManyToOne: This annotation represents a many-to-one relationship, where many entities are related to a single entity. For example, many Comment entities might be related to a single Post entity.
* @ManyToMany: This annotation represents a many-to-many relationship, where many entities are related to many other entities. For example, a User entity might have many Role entities, and a Role entity might have many User entities.
## 7. What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?
    The cascade = CascadeType.ALL, orphanRemoval = true annotation in JPA defines how changes to the parent entity should be cascaded to its associated entities. The CascadeType.ALL value specifies that all operations (such as persist, merge, remove, etc.) should be cascaded to the associated entities. The orphanRemoval = true value specifies that any associated entities that are no longer referenced by the parent entity should be removed. 

    The other CascadeType values include:

    CascadeType.PERSIST: Specifies that the persist operation should be cascaded.
    CascadeType.MERGE: Specifies that the merge operation should be cascaded.
    CascadeType.REMOVE: Specifies that the remove operation should be cascaded.
    CascadeType.REFRESH: Specifies that the refresh operation should be cascaded.
    The choice of CascadeType depends on the requirements of the application and the desired behavior of the cascading operations.
## 8.  What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
    The fetch = FetchType.LAZY, fetch = FetchType.EAGER annotation in JPA determines when the associated entities should be fetched from the database. The FetchType.LAZY value specifies that the entities should be fetched only when they are needed, while the FetchType.EAGER value specifies that the entities should be fetched immediately when the parent entity is fetched.
    The choice of FetchType depends on the requirements of the application and the desired performance characteristics. For example, if the associated entities are not needed immediately, using FetchType.LAZY can improve performance by avoiding unnecessary database queries, but if the associated entities are needed immediately, using FetchType.EAGER can simplify the code by avoiding the need for additional queries.

## 9.  What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?
    JPA naming convention rules specify how the names of entities, attributes, and relationships should be named in a JPA-based application. The rules typically require that entity names are in singular form and end with the word "Entity", and that attribute names match the names of the corresponding columns in the database. The rules also specify how relationships should be named, such as using the "List" suffix for one-to-many relationships.
    In JPA, it is not necessary to implement the methods yourself, as JPA provides a number of built-in methods for performing common operations such as querying, updating, and deleting entities. However, you can also implement your own custom methods if necessary.
## 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.
    To use JPA advanced methods in a class project, you can use the JPA repository interface to define custom methods that are specific to your application. For example, you might define a method to retrieve all comments for a specific post, or a method to retrieve all posts that were created by a specific user. To use these methods, you would need to follow the JPA naming convention and use the naming conventions provided by JPA in the repository layer.
## 11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-red book/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate.
## 12. (Optional) use JDBC to read the data from database.

## 1.  List all of the annotations you learned from class and homework to annotaitons.md
## 2.  type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.
## 3.  What is JPQL?
    JPQL (Java Persistence Query Language) is a query language used in JPA to perform operations on entities, such as retrieving, updating, and deleting data. JPQL is similar to SQL, but it operates on objects and entities rather than on tables and columns.
## 4.  What is @NamedQuery and @NamedQueries?
    @NamedQuery and @NamedQueries are JPA annotations that define named queries, which are predefined JPQL queries that can be reused throughout the application. @NamedQuery is used to define a single named query, while @NamedQueries is used to define multiple named queries.
## 5.  What is @Query? In which Interface we write the sql or JPQL?
    @Query is a JPA annotation used to define custom JPQL or native SQL queries for a repository. The query is written in the @Query annotation and is executed when the method is called. The query can be written in JPQL or native SQL, depending on the requirements of the application. The interface in which the @Query annotation is written is the repository interface, which defines the methods for accessing the data stored in the database.
## 6.  What is HQL and Criteria Queries?
    HQL (Hibernate Query Language) and Criteria Queries are alternative query languages used in Hibernate to perform operations on entities. HQL is similar to JPQL, but it is specific to Hibernate and has some additional features. Criteria Queries are programmatic queries that are constructed using the Criteria API and can be used to perform dynamic, flexible querying.
## 7. What is EnityManager?
    The EntityManager is the main interface in JPA for accessing and managing entities. It provides a number of methods for performing common operations, such as persisting, merging, and removing entities, as well as executing queries.
## 8.  What is SessionFactory and Session?
    The SessionFactory is a factory class in Hibernate that is used to create Session objects. The Session is the main interface in Hibernate for accessing and managing data, and it provides a number of methods for performing common operations, such as persisting, merging, and removing entities, as well as executing queries.
## 9.  What is Transaction? how to manage your transaction?
    A Transaction is a unit of work in a database that contains one or more operations that must either all be completed or all be rolled back. In JPA and Hibernate, transactions are managed using the EntityManager or the Session, which provide methods for starting, committing, and rolling back transactions.
## 10. What is hibernate Caching?
    Hibernate caching refers to the caching of data in Hibernate to improve performance. Hibernate provides two levels of caching: the first-level cache, which is associated with a Session or EntityManager, and the second-level cache, which is associated with a SessionFactory.
## 11. What is the difference between first-level cache and second-level cache?
    The first-level cache is a cache of data that is associated with a single Session or EntityManager. When data is retrieved from the database, it is stored in the first-level cache, and subsequent requests for the same data will be retrieved from the cache rather than from the database. The first-level cache is useful for improving performance when working with a single transaction, but it is not effective when multiple transactions are accessing the same data.

    The second-level cache is a cache of data that is associated with a SessionFactory and is shared across all Sessions and EntityManagers. When data is retrieved from the database and stored in the first-level cache, it is also stored in the second-level cache, so that subsequent requests for the same data from any Session or EntityManager will be retrieved from the second-level cache rather than from the database.

## 12. How do you understand @Transactional? (不要clone，要自己抄写并测试transactional，https://github.com/TAIsRich/tutorial-transaction)
    @Transactional is a Spring annotation used to indicate that a method should be executed within a transaction. When a method annotated with @Transactional is called, a transaction is started and all the operations within the method are executed within the scope of that transaction. If the method completes successfully, the transaction is committed and the changes are persisted to the database. If an error occurs within the method, the transaction is rolled back and any changes made to the database are undone.
## 13. Write a simple factory design pattern.
```java:
    interface Shape {
        void draw();
    }

    class Circle implements Shape {
    @Override
        public void draw() {
            System.out.println("Drawing Circle");
        }
    }

    class Rectangle implements Shape {
    @Override
        public void draw() {
            System.out.println("Drawing Rectangle");
        }
    }

    class ShapeFactory {
        public static Shape getShape(String shapeType) {
            if (shapeType == null) {
                return null;
            }
            if (shapeType.equalsIgnoreCase("CIRCLE")) {
                return new Circle();
            } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
                return new Rectangle();
            }
            return null;
        }
    }

```