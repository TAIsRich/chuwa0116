# hw10

## 4. what is JPA? and what is Hibernate?

JPA stands for Java Persistence API (Application Programming Interface). It is a Java specification that gives some functionality and standard to ORM tools. It is used to examine, control, and persist data between Java objects and relational databases. It is observed as a standard technique for Object Relational Mapping. 

The main feature of Hibernate is to map the Java classes to database tables. It is an implementation of JPA guidelines. It helps in mapping Java data types to SQL data types. It is the contributor of JPA.

## 5. What is Hiraki? what is the benefits of connection pool?

It is a JDBC connection pool.

Connection pools promote the reuse of connection objects and reduce the number of times that connection objects are created. 

## 6. What is the @OneToMany, @ManyToOne, @ManyToMany ? write some examples.

@OneToMany: One record in the table relates multiple records in another table.

@ManyToOne: Multiple records in the table relate to one record in another table.

@ManyToMany: Multiple records in the table relate to multiple records in another table.

```Java
@Entity
@Table(name = "university")
public class University {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "university", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Student> students;

    /* Getters and setters */
}

@Entity
@Table(name = "student")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "university_id")
    private University university;

    /* Getters and setters */
}
```


```Java
@Entity
@Table(name="course")
public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private Double fee;

    @ManyToMany(mappedBy = "courses")
    private Set<Student> students;

    /* Getters and setters */
}

@Entity
@Table(name="student")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(cascade = {
            CascadeType.PERSIST,
            CascadeType.MERGE
    })
    @JoinTable(
            name = "student_course",
            joinColumns = {@JoinColumn(name = "student_id")},
            inverseJoinColumns = {@JoinColumn(name = "course_id")}
    )
    private Set<Course> courses;

    /* Getters and setters */
}
```

## 7. What is the cascade = CascadeType.ALL, orphanRemoval = true ? and what are the other CascadeType and their features? In which situation we choose which one?

JPA Cascade Type: 
- ALL
- PERSIST
- MERGE
- REMOVE
- REFRESH
- DETACH

CascadeType.PERSIST: When persisting an entity, also persist the entities held in its fields. We suggest a liberal application of this cascade rule, because if the EntityManager finds a field that references a new entity during the flush, and the field does not use CascadeType.PERSIST, it is an error.

CascadeType.REMOVE: When deleting an entity, it also deletes the entities held in this field.

CascadeType.REFRESH: When refreshing an entity, also refresh the entities held in this field.

CascadeType.MERGE: When merging entity state, also merge the entities held in this field.

CascadeType.ALL contains all above actions.

orphanRemoval=true: The orphanRemoval is an ORM concept, it tells if the child is orphaned. it should also be removed from the database.

## 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER ? what is the difference? In which situation you choose which one?

Eager Loading is a design pattern in which data initialization occurs on the spot.
Lazy Loading is a design pattern that we use to defer initialization of an object as long as it's possible.


## 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

Using camelCase and some keywords indicts some operations.

```Java
List<Student> students1 = repository.findByStudentId(1L);
List<Student> students2 = repository.findByStudentIdLessThanAndMarksGreaterThan(3L, 99L);
```

# Part 2

## 3. What is JPQL?

The JPQL (Java Persistence Query Language) is an object-oriented query language which is used to perform database operations on persistent entities. Instead of database table, JPQL uses entity object model to operate the SQL queries. 

Tthe role of JPA is to transform JPQL into SQL. Thus, it provides an easy platform for developers to handle SQL tasks.

## 4. What is @NamedQuery and @NamedQueries?

@NameQueries annotation is used to define the multiple named queries.

@NameQuery annotation is used to define the single named query.

## 5. What is @Query? In which Interface we write the sql or JPQL?

In order to define SQL to execute for a Spring Data repository method, we can annotate the method with the @Query annotation — its value attribute contains the JPQL or SQL to execute.

Repository Interface

## 6. What is HQL and Criteria Queries?

HQL stands for Hibernate Query Language. It's an object-oriented language similar to SQL that we can use to query our database. However, the main disadvantage is the code's unreadability. We can define our queries as Named Queries to place them in the actual code that accesses the database.

The Criteria API helps in building the Criteria query object by applying different filters and logical conditions on top of it. This is an alternate way to manipulate objects and return the desired data from an RDBMS table.

## 7. What is EnityManager?

A JPA EntityManager manages connection to a database as well as to database
operations.

## 8. What is SessionFactory and Session?

SessionFactory is a factory class for Session objects. It is available for the whole application while a Session is only available for particular transaction.

The session object provides an interface between the application and data stored in the
database.


## 9. What is Transaction? how to manage your transaction?

Transactions are a set of operations used to perform a logical set of work. 

## 10. What is hibernate Caching?

Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database.

## 11. What is the difference between first-level cache and second-level cache?

Hibernate first level cache is session specific, that’s why when we are
getting the same data in same session there is no query fired whereas in
other session query is fired to load the data.

Hibernate first level cache can have old values — Two session works on
the same object, the second session update the object and save to
database, but it won’t reflect in the first session cache.

Second level cache is based on entity and shared among sessions. If an instance is already present in the first-level cache, it is returned from there. If an instance is not found in the first-level cache, and the corresponding instance state is cached in the second-level cache, then the data is fetched from there and an instance is assembled and returned


## 12. How do you understand @Transactional? 

It is used to combine more than one writes on a database as a single atomic operation. 


## 13. Write a simple factory design pattern.

```Java
public interface Laptop {
    void runTests();
}

public class NormalLaptop implements Laptop {

    @Override
    public void runTests() {
       System.out.println("Running tests on a NormalLaptop...");
    }
}

public class GamingLaptop implements Laptop {

    @Override
    public void runTests() {
       System.out.println("Running tests on a GamingLaptop...");
    }
}

public class LaptopFactory {

    // Objects are created here 
    public Laptop createLaptop(String laptopType){
        if (laptopType == null) {
            return null;
        }

        switch (laptopType.toUpperCase()) {
            case "NormalLaptop":
                return new NormalLaptop();
                break;
            case "GamingLaptop":
                return new GamingLaptop();
                break;
                
            default:
                return null;
        }
    }
}

public class Client {
    public static void main(String[] args) {
        LaptopFactory laptopFactory = new LaptopFactory();

        // Get object of type GamingLaptop and run tests.
        Laptop myLaptop = laptopFactory.createLaptop("GamingLaptop");

        myLaptop.runTests();
    }
}
```
