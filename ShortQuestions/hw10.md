#### 1. what is JPA? and what is Hibernate?    
JPA(Java Persistence API) is a specification for object-relational mapping (ORM) in Java. which defines a set of standard interfaces and annotations for persisting Java objects to relational database.    

Hibernate, on the other hand, is a popular Java ORM framework that implements the JPA specification. It provides a wide range of features for mapping Java objects to database tables, including support for lazy loading, caching, and transaction management. Hibernate also includes additional features beyond the JPA specification, such as support for native SQL queries and custom type mappings.   

#### 2. what is hikari? what is the benefits of connection pool?     
HikariCP is a high-performance, open-source JDBC connection pool for Java applications. It is designed to provide fast and efficient management of database connections, with low overhead and minimal latency.    

HikariCP is often preferred over other connection pool libraries due to its small footprint, fast startup time, and low resource consumption. It is highly configurable and supports a wide range of database systems, including MySQL, PostgreSQL, Oracle, and Microsoft SQL Server.     

The benefits of connections pooling include:    
1. Improved performance: Since creating a new connection to the database is a relatively expensive operation, reusing existing connections from the pool can significantly reduce the overhead associated with establishing a new connection.     
2. Better scalability: By limiting the number of connections that can be created to the database, connection pooling can help prevent overload on the database server and improve application scalability.    
3. More efficient resource utilization: By reusing existing connections, connection pooling can help reduce the number of idle connections and improve overall resource utilization.     
4. Enhanced reliability: Connection pooling can help prevent database connection errors by ensuring that each connection is properly initialized and configured before being assigned to a client.    
Overall, connection pooling is an effective technique for optimizing the use of database resources and improving the performance and scalability of database-driven applications.       

#### 3. What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.    
@OneToMany, @ManyToOne, and @ManyToMany are annotations commonly used in object-relational mapping frameworks such as Hibernate or JPA to define relationships between entities in a database.      

@OneToMany: Indicates a one-to-many relationship between two entities, where one entity can have multiple instances of the other entity. For example, a Customer can have multiple Orders.      
@ManyToOne: Indicates a many-to-one relationship between two entities, where multiple instances of one entity can be associated with a single instance of another entity. For example, multiple Orders can be associated with a single Customer.       
@ManyToMany: Indicates a many-to-many relationship between two entities, where multiple instances of one entity can be associated with multiple instances of another entity. For example, a Book can have multiple Authors, and an Author can write multiple Books.       

Here are some code examples in Java:      
```
// One-to-many relationship
@Entity
public class Customer {
    @OneToMany(mappedBy = "customer")
    private List<Order> orders;
}

@Entity
public class Order {
    @ManyToOne
    private Customer customer;
}

// Many-to-one relationship
@Entity
public class Order {
    @ManyToOne
    private Customer customer;
}

@Entity
public class Customer {
    @OneToMany(mappedBy = "customer")
    private List<Order> orders;
}

// Many-to-many relationship
@Entity
public class Book {
    @ManyToMany
    @JoinTable(name = "book_author",
        joinColumns = @JoinColumn(name = "book_id"),
        inverseJoinColumns = @JoinColumn(name = "author_id"))
    private List<Author> authors;
}

@Entity
public class Author {
    @ManyToMany(mappedBy = "authors")
    private List<Book> books;
}

```

#### 4. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what 
are the other CascadeType and their features? In which situation we choose 
which one?        
In object-relational mapping frameworks such as Hibernate or JPA, 'cascade' and 'orphanRemoval' are options that can be set for entity associations to define how changes made to one entity affect associated entities.      
1. 'cascade = CascadeType.ALL': This option specifies that all operations(e.g. persist, merge, remove, refresh) should be cascaded from the parent entity to the associated entity.         
2. 'orphanRemoval = true': This option specifies that when an associated entity is removed from the parent entity, it should be deleted from the database.         
Other CascadeType options include:         
CascadeType.PERSIST: Cascades the persist operation from parent to associated entities.                 
CascadeType.MERGE: Cascades the merge operation from parent to associated entities.               
CascadeType.REMOVE: Cascades the remove operation from parent to associated entities.                
CascadeType.REFRESH: Cascades the refresh operation from parent to associated entities.                 
CascadeType.DETACH: Cascades the detach operation from parent to associated entities.                
The choice of CascadeType depends on the specific requirements of the application. For example, if an associated entity should always be saved or deleted along with the parent entity, CascadeType.ALL might be appropriate. If an associated entity should be removed when it is no longer associated with any parent entity, orphanRemoval might be appropriate.     
Here is an example of how CascadeType and orphanRemoval might be used:     
```
@Entity
public class Department {
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Employee> employees;
}

@Entity
public class Employee {
    @ManyToOne
    private Department department;
}
```
In this example, when a Department entity is deleted, all associated Employee entities will also be deleted (because of CascadeType.ALL). When an Employee is removed from a Department (e.g. by setting its department field to null), it will be deleted from the database if it is no longer associated with any Department (because of orphanRemoval).    

#### 5. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?     
FetchType.LAZY and FetchType.EAGER are used to specify how associated entities should be fetched when querying a database using an ORM framework like Hibernate.     
FetchType.LAZY means that associated entities will not be fetched from the database until they are accessed for the first time. This can be useful for improving performance when working with large object graphs where not all data is needed at once.       
FetchType.EAGER means that associated entities will be fetched from the database at the same time as the main entity. This can be useful when all associated entities are needed to be accessed together.       
Which one to choose depends on the specific use case. In general, FetchType.LAZY is a good default choice as it can help avoid unnecessary data retrieval and improve performance. However, there may be situations where FetchType.EAGER is more appropriate, such as when working with small object graphs where all data is needed at once.     

#### 6. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?     
JPA naming convention is a set of rules that define how entities, properties, and relationships should be named in Java code to be mapped to corresponding database objects.      

The main rules for JPA naming convention are:    

Entity names should be singular and capitalized, e.g., Customer, Order.
Property names should start with a lowercase letter and use camelCase, e.g., firstName, orderDate.     
Primary key fields should be named id.     
Join table names should be a combination of the names of the two related entities, in alphabetical order and separated by an underscore, e.g., customer_order.     
JPA naming convention also provides default naming for methods that perform CRUD (Create, Read, Update, Delete) operations on entities. These methods are:       
save or persist - for creating a new entity or updating an existing one.     
findById or getById - for retrieving an entity by its primary key.     
findAll - for retrieving all entities of a certain type.        
delete - for deleting an entity.     
You don't have to implement these methods yourself if you are using an ORM framework like Hibernate or Spring Data JPA. These methods are automatically generated by the framework based on the naming convention and the entity class definition.    

Here are some examples of JPA naming convention applied to entity classes:    
```
@Entity
public class Customer {
    @Id
    @GeneratedValue
    private Long id;
    private String firstName;
    private String lastName;
    // getters and setters
}

@Entity
public class Order {
    @Id
    @GeneratedValue
    private Long id;
    private Date orderDate;
    @ManyToOne
    private Customer customer;
    // getters and setters
}

```
Assuming these entity classes are mapped to corresponding database tables, the table names and column names will follow the JPA naming convention rules as well.      

#### 7. What is JPQL?      
JPQL stands for Java Persistence Query Language. It is a platform-independent object-oriented query language used to perform database operations on Java objects in a Java Persistence API (JPA) context. JPQL is similar to SQL but operates on JPA entities rather than database tables.     

#### 8. What is @NamedQuery and @NamedQueries?     
@NamedQuery and @NamedQueries are annotations in JPA (Java Persistence API) used to define named queries for entities.     

@NamedQuery is used to define a single named query for an entity. It takes two arguments: the name of the query, and the JPQL query string.    

@NamedQueries is used to define multiple named queries for an entity. It takes an array of @NamedQuery annotations as an argument, each defining a different named query.    

Both of these annotations can be used to define queries that can be reused across different parts of an application, making it easier to manage and maintain queries.        

#### 9. What is @Query? In which Interface we write the sql or JPQL?         
@Query is an annotation in Spring Data that is used to define custom queries for JPA repositories. It allows you to write queries in either SQL or JPQL (Java Persistence Query Language) to fetch data from the database.       
The @Query annotation is used on a method in a repository interface, and the query can be written either in the native SQL dialect of the database or in JPQL.    
For example, here's how you can use the @Query annotation to define a custom SQL query for a Spring Data JPA repository:    
```
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.email = ?1")
    User findByEmail(String email);
}
``` 
In this example, the @Query annotation is used to define a JPQL query that selects a User entity by their email address.      
You can also use native SQL with @Query by setting the nativeQuery attribute to true:      
```
public interface UserRepository extends JpaRepository<User, Long> {
    @Query(value = "SELECT * FROM users WHERE email = ?1", nativeQuery = true)
    User findByEmail(String email);
}
```
This example uses a native SQL query to select a user from the users table by their email address.     

By using @Query, you can write custom queries that go beyond the basic CRUD operations provided by Spring Data JPA.     

#### 10. What is HQL and Criteria Queries?     
HQL (Hibernate Query Language) and Criteria Queries are two query languages provided by Hibernate, a popular Java ORM (Object-Relational Mapping) framework.      

HQL is a powerful object-oriented query language that is very similar to SQL, but operates on Hibernate's persistent objects instead of database tables. It uses the same syntax as SQL, but refers to entities and properties instead of tables and columns.      

Here is an example of an HQL query that selects all Product entities that are in the electronics category:      
```
Query query = session.createQuery("FROM Product p WHERE p.category = 'electronics'");
List<Product> products = query.list();
```
Criteria Queries, on the other hand, provide a type-safe and programmatic way of constructing queries using Java objects and methods. It allows you to build queries dynamically and is particularly useful when constructing complex queries with multiple conditions.     

Here is an example of a Criteria Query that selects all Product entities that are in the electronics category:     
```
CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<Product> criteria = builder.createQuery(Product.class);
Root<Product> root = criteria.from(Product.class);
criteria.select(root).where(builder.equal(root.get("category"), "electronics"));
List<Product> products = session.createQuery(criteria).list();
```
In this example, we use the Criteria API to dynamically construct a query that selects Product entities with a category property equal to "electronics". The resulting query is more type-safe and easier to maintain than the equivalent HQL query.     

#### 11. What is EnityManager?     
EntityManager is a key interface in the Java Persistence API (JPA) that provides methods for managing persistent objects in a JPA context. It serves as the primary interface between a JPA application and the underlying database.     
The EntityManager interface provides methods for performing common database operations such as persisting, merging, deleting, and querying entities. It is responsible for managing the lifecycle of JPA entities, ensuring that changes made to entities are synchronized with the underlying database.     
The EntityManager interface is typically obtained from an instance of the EntityManagerFactory class, which is responsible for creating and managing EntityManager instances. An EntityManager instance is associated with a JPA persistence context, which represents the state of the database at a given point in time.     
Here is an example of how to obtain an EntityManager instance and use it to persist a Product entity:     
```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("myPersistenceUnit");
EntityManager em = emf.createEntityManager();

Product product = new Product();
product.setName("iPhone");
product.setCategory("electronics");
product.setPrice(999.99);

em.getTransaction().begin();
em.persist(product);
em.getTransaction().commit();

em.close();
emf.close();
```
In this example, we first obtain an EntityManager instance from an EntityManagerFactory using a persistence unit name. We then create a Product instance and use the persist() method of the EntityManager to save it to the database. Finally, we commit the transaction and close the EntityManager and EntityManagerFactory instances.     
The EntityManager interface provides a powerful set of methods for working with JPA entities, making it a central component of JPA-based applications.     

#### 12. What is SessionFactory and Session?     
SessionFactory and Session are key interfaces in Hibernate, a popular Java ORM (Object-Relational Mapping) framework.    

The SessionFactory is a factory of Session instances, which provides an immutable thread-safe cache of compiled mappings for a single database. It is responsible for creating and managing the Session instances that are used to interact with the database.    

The Session is the primary interface for working with persistent objects in Hibernate. It represents a single unit of work with the database and provides methods for persisting, updating, and querying entities.   

Here is an example of how to use a SessionFactory to create a Session and persist a Product entity:    
```
SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
Session session = sessionFactory.openSession();

Product product = new Product();
product.setName("iPhone");
product.setCategory("electronics");
product.setPrice(999.99);

Transaction tx = session.beginTransaction();
session.persist(product);
tx.commit();

session.close();
sessionFactory.close();
```
In this example, we first create a SessionFactory instance by reading the configuration from the hibernate.cfg.xml file. We then use the openSession() method to create a new Session instance. We create a Product entity and use the persist() method of the Session to save it to the database. Finally, we commit the transaction and close the Session and SessionFactory instances.    

The SessionFactory and Session interfaces provide a powerful set of methods for working with Hibernate entities and the underlying database, making it a popular choice for Java-based ORM applications.    

#### 13. What is Transaction? how to manage your transaction?    
In the context of a database, a transaction is a series of operations performed as a single unit of work. A transaction typically involves reading and/or modifying data in a database, and it needs to ensure that the data remains consistent and correct.      

Transactions provide a way to group together a set of related database operations and ensure that they are all executed as a single, atomic operation. This means that either all of the operations succeed, or none of them do. If a transaction fails, all of the changes made during the transaction are rolled back, and the database is returned to its original state.     

In Java, transactions can be managed using either the JPA API or the Hibernate API, depending on the ORM framework being used. Here is an example of how to manage a transaction using JPA:      
```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("myPersistenceUnit");
EntityManager em = emf.createEntityManager();

try {
    em.getTransaction().begin();

    // Perform some database operations here

    em.getTransaction().commit();
} catch (Exception e) {
    if (em.getTransaction().isActive()) {
        em.getTransaction().rollback();
    }
} finally {
    em.close();
    emf.close();
}
```
In this example, we first obtain an EntityManager instance and begin a new transaction using the getTransaction() method. We then perform some database operations inside the transaction, and commit the transaction when we're done. If an exception is thrown, we catch it and roll back the transaction using the rollback() method. Finally, we close the EntityManager and EntityManagerFactory instances.

The exact process for managing transactions may vary depending on the specific requirements of the application and the ORM framework being used, but the basic principles of ensuring atomicity, consistency, isolation, and durability (ACID) are generally followed.     

#### 14. What is hibernate Caching? What is the difference between first-level cache and second-level cache?    
Hibernate caching is a mechanism for improving the performance of database operations by storing frequently accessed data in memory. Hibernate provides several types of caching, each with its own strengths and limitations:

1. First-level cache: This is the default cache that Hibernate provides for each Session object. It stores the objects that have been queried or saved during the current session, and avoids unnecessary trips to the database for subsequent access to the same data.     
2. Second-level cache: This is a shared cache that can be used across multiple Session objects, and is typically implemented using a third-party cache provider such as Ehcache or Infinispan. It stores entities and collections that have been queried or saved across different sessions, and provides faster access to frequently accessed data.     
3. Query cache: This cache stores the results of frequently executed queries, and can be used to avoid executing the same query multiple times.   
Caching can significantly improve the performance of database operations by reducing the number of database trips and improving response times. However, caching also introduces some complexity and potential issues, such as cache invalidation, stale data, and memory usage. It is important to use caching judiciously and test the application thoroughly to ensure that caching is providing the intended benefits without introducing any issues.    
     











 







