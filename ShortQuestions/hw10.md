1.  what is JPA? and what is Hibernate?
   
JPA is only a specification, it is not an implementation.
It is a set of rules and guidelines to set interfaces for implementing object-relational mapping, .
It needs a few classes and interfaces.
It supports simple, cleaner, and assimilated object-relational mapping.
It supports polymorphism and inheritance.
Dynamic and named queries can be included in JPA.

The main feature of Hibernate is to map the Java classes to database tables. Following are some key features of Hibernate :

Hibernate is an implementation of JPA guidelines.
It helps in mapping Java data types to SQL data types.
It is the contributor of JPA.

2.  What is Hiraki? what is the benefits of connection pool?

HikariCP is a very fast lightweight Java connection pool. The API and overall codebase is relatively small (A good thing) and highly optimized. It also does not cut corners for performance like many other Java connection pool implementations. The Wiki is highly informative and dives really deep.
   
3.  What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.

OneToMany: As its name implies, it’s a relationship that links one entity to many other entities.
    ```
    @Entity
    @Table(name = "university")
    public class University {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;

        @OneToMany(mappedBy = "university", cascade = CascadeType.ALL, orphanRemoval = true)
        private List<Student> students;

        /* Getters and setters */
    }

    @Entity
    @Table(name = "student")
    public class Student {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;

        @ManyToOne
        @JoinColumn(name = "university_id")
        private University university;

    /* Getters and setters */
    }
    ```

ManyToOne: A many-to-one mapping means that many instances of this entity are mapped to one instance of another entity – many items in one cart.

    ```

ManyToMany: A relationship is a connection between two types of entities. In the case of a many-to-many relationship, both sides can relate to multiple instances of the other side.
    ```
    @Entity
    @Table(name="course")
    public class Course {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;

        private Double fee;

        @ManyToMany(mappedBy = "courses")
        private Set<Student> students;

        /* Getters and setters */
    }


    @Entity
    @Table(name="student")
    public class Student {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;

        @ManyToMany(cascade = {
                CascadeType.PERSIST,
                CascadeType.MERGE
        })
        @JoinTable(
                name = "student_course",
                joinColumns = {@JoinColumn(name = "student_id")},
                inverseJoinColumns = {@JoinColumn(name = "course_id")}
        )
        private Set<Course> courses;

        /* Getters and setters */
    }
    ```

   
4. What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?

ALL indicates that when we persist, remove, refresh or merge this entity all the entities held in this field would be persist, remove, delete or update.

Orphan removal means that dependent entities are removed when the relationship to their "parent" entity is destroyed. 

CascadeType.PERSIST: cascade type presist means that save() or persist() operations cascade to related entities.
CascadeType.MERGE: cascade type merge means that related entities are merged when the owning entity is merged.
CascadeType.REFRESH: cascade type refresh does the same thing for the refresh() operation.
CascadeType.REMOVE: cascade type remove removes all related entities association with this setting when the owning entity is deleted.
CascadeType.DETACH: cascade type detach detaches all related entities if a “manual detach” occurs.
CascadeType.ALL: cascade type all is shorthand for all of the above cascade operations.
   
5.  What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the 
difference? In which situation you choose which one?

To load it together with the rest of the fields (i.e. eagerly), or
To load it on-demand (i.e. lazily) when you call the university's getStudents() method.

6.  What is the rule of JPA naming convention? Shall we implement the method by 
ourselves? Could you list some examples?

ref: https://www.baeldung.com/spring-data-jpa-custom-naming

We have a few names here that have to be mapped to the database. Well, Spring uses lower snake case by default, which means it uses only lower case letters and separates words with underscores. Therefore, the table creation query for the Person entity would be:

    ```
    @Entity
    public class Person {
        @Id
        private Long id;
        private String firstName;
        private String lastName;
    }

    create table person (id bigint not null, first_name varchar(255), last_name varchar(255), primary key (id));

    select first_name from person;
    ```

3. What is JPQL?
   
JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database.

4.  What is @NamedQuery and @NamedQueries?
   
   @NamedQuery: Specifies a static, named query in the Java Persistence query language. 
   @NamedQueries: A named query is a statically defined query with a predefined unchangeable query string. 

5.  What is @Query? In which Interface we write the sql or JPQL?

In order to define SQL to execute for a Spring Data repository method, we can annotate the method with the @Query annotation — its value attribute contains the JPQL or SQL to execute.

The @Query annotation takes precedence over named queries, which are annotated with @NamedQuery or defined in an orm.xml file.

repository 
   
6.  What is HQL and Criteria Queries?

HQL is to perform both select and non-select operations on the data, but Criteria is only for selecting the data, we cannot perform non-select operations using criteria. HQL is suitable for executing Static Queries, where as Criteria is suitable for executing Dynamic Queries.
   
7. What is EnityManager?

The EntityManager is an API that manages the lifecycle of entity instances. An EntityManager object manages a set of entities that are defined by a persistence unit. Each EntityManager instance is associated with a persistence context.
   
8.  What is SessionFactory and Session?

SessionFactory is a factory class for Session objects. It is available for the whole application while a Session is only available for particular transaction. Session is short-lived while SessionFactory objects are long-lived. SessionFactory provides a second level cache and Session provides a first level cache.
   
9.  What is Transaction? how to manage your transaction?

Transactions in DBMS : 
Transactions are a set of operations used to perform a logical set of work. A transaction usually means that the data in the database has changed. One of the major uses of DBMS is to protect the user’s data from system failures. It is done by ensuring that all the data is restored to a consistent state when the computer is restarted after a crash. The transaction is any one execution of the user program in a DBMS. Executing the same program multiple times will generate multiple transactions. 
    
10. What is hibernate Caching?

Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database. It is very useful when you need to fetch the same kind of data multiple times.

    
11.  What is the difference between first-level cache and second-level cache?

first-level: cache in internal session

second-level: cache in external sessions
    

12. How do you understand @Transactional?
    
The @Transactional annotation is metadata that specifies that an interface, class, or method must have transactional semantics; for example, "start a brand new read-only transaction when this method is invoked, suspending any existing transaction".

13.    Write a simple factory design pattern.

please see Coding/coding10/