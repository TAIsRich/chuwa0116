### 4.What is JPA? and what is Hibernate?
* JPA is a Java specification that gives some functionality and standard to ORM tools. It is used to examine, control, and persist data between Java objects and relational databases.
* Hibernate is an open source Object-Relational Persistence and Query service for any Java Application

### 5. What is Hiraki? What is the benefits of connection pool?
*  Hikari is a JDBC DataSource implementation that provides a connection pooling mechanism
* Connection pools promote the reuse of connection objects and reduce the number of times that connection objects are created.

### 6. What is the @OneToMany,@ManyToOne,@ManyToMany? Write some examples.
* @OneToMany means one row in a table can map to many rows from others.
    Eg, departmentId maps to many studentId
* @ManyToOne means many rows in a table can map to one row from others.
    eg. many studentId map to one departmentId
* @ManyToMany means many rows in a table map to many rows from others.
    eg. one courseId can map to many studentId, vice versa

### 7. What is the cascade=CascadeType.ALL, orphanRemoval=true? and what are the other CascadeType and their features? In which situation we choose which one?
* The cascade attribute is set to CascadeType.ALL, meaning that all the JPA and Hibernate entity state transitions (e.g., persist, merge, remove) are passed from the parent Post entity to the PostComment child entities.
* The orphanRemoval attribute is going to instruct the JPA provider to trigger a remove entity state transition when a PostComment entity is no longer referenced by its parent Post entity.

### 8. What is the fetch=FetchType.LAZY, fetch=FetchType.EAGER?

* Eager Loading is a design pattern in which data initialization occurs on the spot.
* Lazy Loading is a design pattern that we use to defer initialization of an object as long as it's possible.

### 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?
* The JPA default table name is the name of the class (minus the package) with the first letter capitalized.
* findByLastnameAndFirstname
* findByLastnameOrFirstname
* findByFirstname


### 3. What is JPQL?
* The Java persistence query language (JPQL) is used to define searches against persistent entities independent of the mechanism used to store those entities. 

### 4. What is @NameQuery and @NamedQueries?
* @NameQuery annotation is used to define the single named query.
* A named query is a SQL expression represented as a table.

### 5. What is @Query? In which Interface we write the sql or JPQL?
* The @Query annotation declares finder queries directly on repository methods.

### 6. What is HQL and Criteria Queries?
* HQL is to perform both select and non-select operations on the data, but Criteria is only for selecting the data, we cannot perform non-select operations using criteria. 

### 7. What is EntityManager?
* The EntityManager API is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities. 

### 8. What is SessionFactory and Session?
* SessionFactory is a factory class for Session objects. It is available for the whole application while a Session is only available for particular transaction.
* Session is short-lived while SessionFactory objects are long-lived. 

### 9. What is Transaction? How to manage your transaction?
* The @Transactional annotation is the metadata that specifies the semantics of the transactions on a method.

### 10. What is hibernate Caching?
* Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data â€” as it fetches from memory instead of directly hitting the database. 


### 11. What is the difference between first-level cache and second-level cache?
* The first level cache is associated with the Session Object, while the second-level cache is associated with the SessionFactory object.

### 13. Write a simple factory design pattern.
``` 
public interface Laptop {
    void runTests();
}
```




``` 
public class NormalLaptop implements Laptop {

    @Override
    public void runTests() {
       System.out.println("Running tests on a NormalLaptop...");
    }
}
```




``` 
public class GamingLaptop implements Laptop {

    @Override
    public void runTests() {
       System.out.println("Running tests on a GamingLaptop...");
    }
}
```




``` 
public class LaptopFactory {

    public Laptop createLaptop(String laptopType){
        if (laptopType == null) {
            return null;
        }

        switch (laptopType.toUpperCase()) {
            case "NormalLaptop":
                return new NormalLaptop();
                break;
            case "GamingLaptop":
                return new GamingLaptop();
                break;
                
            default:
                return null;
        }
    }
}
```


``` 
public class Client {
    public static void main(String[] args) {
        LaptopFactory laptopFactory = new LaptopFactory();

        // Get object of type GamingLaptop and run tests.
        Laptop myLaptop = laptopFactory.createLaptop("GamingLaptop");

        myLaptop.runTests();
    }
}
```



