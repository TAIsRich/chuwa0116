##1. List all annotations you learned from class and homework to annotaitons.md
####Answer:
    The answer is in the ShortQuestions/annotations.md.

##2. what is the @configuration and @bean?
####Answer:
    1)@Configuartion: @Configuration Annotates the class to configure the Spring container (application context). This class 
    is equivalent to <beans> in spring's xml configuration file. Methods annotated with the @Bean annotation in the @Configuration 
    annotation class return types that are directly registered as beans.(Note: The configuration class of the @Configuration annotation 
    has the following requirements: @Configuration cannot be final, @Configuration cannot be an anonymous class, and Nested @Configuration
    must be a static class.)
    2)@Bean: class contains one or more be @ Bean annotation methods, these methods will be AnnotationConfigApplicationContext or
    AnnotationConfigWebApplicationContext scanned. It is used to build bean definitions and initialize the Spring container.
    In conclusion, @Configuration starts the container and @Bean registers beans. The life cycle of beans is managed under @Bean. 
    The @Bean annotation is on the method (the method that returns an instance), equivalent to spring's xml configuration file, 
    and is used to register the bean object. Since the purpose of @Bean is to register bean objects, you can register beans 
    using annotations like @Component, @Controller, @Service, and @Ripository. it is definitely need to configure @ComponentScan for
    automatic scanning.

##3. How do you handle the exception in Spring?
####Answer:
    By using unified exception handling, these duplicate try-catch blocks are extracted, allowing us to focus on the business logic 
    and have unified control over the handling of exceptions.
    1)In method level, using @ExceptionHandler annotation to handle the exceptions and sending the custom responses to the 
    client. The @ExceptionHandler annotation allows you to handle local exceptions of Controller.
    In class level, using @ControllerAdvice to handle the exceptions globally. It is a Controller enhancer that adds some logical handling 
    to the @RequestMapping annotated methods in controller, most commonly exception handling. By useing with @ExceptionHandler,
    When an exception is thrown to the controller, it can be handled uniformly, specifying the json format to return or redirected to an error page.
    2)The step is: create ErrorDetails Class -> create GlobalExceptionHandler class -> test using Postman Client.
    the example for handling the exception:
 ```
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorDetails>  handleResourceNotFoundException(ResourceNotFoundException  exception,
                                                                   WebRequest webRequest) {
        ErrorDetails errorDetails = new ErrorDetails(new Date(), exception.getMessage(), webRequest.getDescription(false));
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
}
```  
```
@ControllerAdvice
public class ControllerExceptionHandler{
    @ExceptionHandler(Exception.class)
    //@ResponseBody// if used @RestControllerAdvice, there is no need to write @ResponseBody
    public ResponseEntity<ErrorDetails>  handleResourceNotFoundException(ResourceNotFoundException  exception,
                                                                   WebRequest webRequest) {
        ErrorDetails errorDetails = new ErrorDetails(new Date(), exception.getMessage(), webRequest.getDescription(false));
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }
}

```

##4. How do you do the validations in Spring?
####Answer:
    1)Validations is used to Validate the request Body and customize to return some information.
    2)step:
    1.import dependency in pom.xml:
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
    <version>2.7.0</version>
</dependency>
```
    2.Add validation rule to payload, using annotations like @Size, @NotEmpty.
    3.Add @Valid to controller to apply the rule, for example:
```
@PostMapping
public ResponseEntity<PostDTO> createPost(@Valid @RequestBody postDTO postDTO){
    return new ResponseEntity<>(postService.createPost(postDTO), HttpStatus.CREATED);
}

```
    4.Check it in Postman.

##5. What is the actuator?
####Answer:
    It is used to monitor the application. It provides additional capabilities to monitor and manage online applications 
    through HTTP or JMX, including moderation, service health, and metrics collection. These capabilities are accessed through 
    endpoints, Each endpoint can be enabled(enabled), disabled(disabled) and exposed(exposed) over Http or JMX. When dependencies 
    are added to the project, endpoints are automatically registered with the application as they become available and can be accessed 
    via HTTP or JMX. 
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

##1. List all annotations you learned from class and homework to annotations.md
####Answer:
    The answer is in the ShortQuestions/annotations.md.

##2. What is Spring and Springboot? What is the benefits of using Springboot?
####Answer:
    1)Spring: it is a framework that enables rapid development of Java EE applications. It provides a range of underlying 
    containers and infrastructure and seamlessly integrates with a number of commonly used open source frameworks, which makes
    it a must for developing Java EE applications. The Spring Framework mainly includes serveral modules: Containers that support IoC and AOP, 
    supporting JDBC and ORM data access module, modules that support declarative transactions, supporting MVC development 
    based on Servlet, supporting Reactive Web development, as well as integrate JMS, JavaMail, JMX, cache and other modules.
    2)Springboot: it is a framework that simplifies Spring development. It is a repackaging based on the Spring framework. 
    Through automatic configuration, it simplifies the configuration required for the integration of different frameworks. 
    Spring Boot is a big integration of Spring technology stack.
    3)Benefits:
    1.Quickly create stand-alone Spring projects and integrate with major frameworks.
    2.With embedded Servlet containers, applications do not need to be packaged as war packages.
    3.Automatic dependency and version control through starter.
    4.A lot of automatic configuration to simplify development, and you can also change the default values.
    5.No need for XML configuration, no need for code generators, it is right out of the box.
    6.Simple deployment, easy maintenance and upgrade.
    7.Natural fit with microservice and cloud computing.

##3. What is IOC and What is DI?
####Answer:
    IoC(Inversion of Control) is a design principle in object-oriented programming, which can be used to reduce coupling between
    code. One of the most common is called DI(Dependency Inversion), and another is called Dependency Lookup. DI tells Spring 
    to  inject the bean for this variable. The difference is that DI is a passive receiving object, and the dependent B object
    is created during the creation of the instance of class A, and different objects are injected into different attributes 
    according to the type or name. While Dependency Lookup is an active to obtain the corresponding type of objects, and 
    the time of obtaining dependent objects can also be freely controlled in the code.

##4. What is @ComponentScan?
####Answer:
    @ComponentScan defines where the Spring need to scan the bean definations and generate the beans. It directs Spring to 
    search for components in the path specified.

##5. How to define which package spring need to scan in xml and annotation?
####Answer:
    1)XML:
```
<context:component-scan base-package="com.packagename"></context:component-scan>
```
    2)Annotation:
```
@Configuration
@ComponentScan(value="com.packagename")
```
    Plus, We can use the @ComponentScan annotation to specify which packages Spring scans, excludeFilters() to specify 
    which components to exclude, and includeFilters() to specify which components to include. When you use includeFilters() 
    to specify which components to include only, you need to disable the default filtering rules. IncludeFilters specifies 
    the component to be scanned. The includeFilters property has useDefaultFilters. The default value is true, which means 
    that all packages will be scanned by default. useDefaultFilters=false.
```
@Configuration
@ComponentScan(value="com.packagename",includeFilters = {@Filter(type=FilterType.ANNOTATION,classes = {Service.class,Repository.class})},useDefaultFilters = false).

```

##6. What is @SpringbootApplication?
####Answer:
    It includes @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan. 
    1)@SpringBootConfiguration:  it declares a class as the source for bean definitions.
    2)@EnableAutoConfiguration: it allows the application to add beans using classpath definitions.
    3)@ComponentScan: it  directs Spring to search for components in the path specified.

##7. How many ways we can define a bean?
####Answer:
    1)Java annotation mode: we can use @Component, @Service, @Repository, and @Contraoller. If classes are scanned with 
    annotations such as @Component, @Repository, @Controller, @Service, etc., register these classes as beans. The default 
    value for such annotations is the first letter of the class name in lower case. The value of the annotation corresponds 
    to the id value of the Bean in the xml configuration file.
```
@Service
public class PostServiceImpl implements PostService{

}
```
    2)Java configuration class mode: A new class can be brought into a Java configuration mode by using the @Configuration. 
    The @Bean annotation can define a Bean, and specify scanning packages by using the @ComponentScan. The @Bean can be 
    annotated with @Scope("singleton") which specifies a single instance. And  @Scope("prototype") specifying multiple instances.
```
@Configuration
publc class beanMethod2{
    @Bean
    public Student student(){
    
    }
}
```
    3)when using XML: define beans through Spring configuration file and create a spring-conf.xml file in the src directory.
    (Note, the file can be named by yourself. After compiling the program, make sure the file is in the classpath.)
```
<bean id="dataNucleusChuwaNoComponent"
    class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent"></bean>
```

##8. What is default bean name for @Component and @Bean?
####Answer:
    1)When Spring scans a class annotated with @Component, by default it defines a bean with beanName as the class name, 
    starting with a lowercase letter.
    2)When Spring parses the class, it identifies all methods annotated with @Bean, executes them, and registers the return 
    value of the methods in the IoC container. By default, the method name is the Bean name.

##9. What is the difference between @component and @service,@repository?
####Answer:
    1)Relation: @Componet is a general purpose stereotype annotation which indicates that the class annotated with it, is a 
    spring managed component. And @Controller, @Service and @Repository are special types of @Component. The classes annotated 
    with these annotations are picked up in component scanning, and will be managed by Spring.
    2)@Controller: The classes annotated with @Controller will act as Spring MVC controllers. DispatcherServlet looks for
    @RequestMapping in classes that are annotated with @Controller. That means you cannot replace @Controller with @Component, if 
    you just replace it with @Component, then it will be managed by Spring, but it will not be able to handle the requests. 
    Note: if a class is registered with Spring using @Component, then @RequestMapping annotations within class can be picked up,
    if the class itself is annotated with @RequestMapping.
    3)@Service: The classes in service layer containing the business logic should be annotated with @Service. Apart from 
    the fact that it is used to indicate that the class contains business logic, there is no special meaning to this annotation.
    However, it is possible that Spring may add some additional feature to @Service in future, so it is always good idea to follow the convention.
    4)@Repository: the classes annotated with this annotation defines data repositories. It is used in DAO layer classes. 
    @Repository has one special feature that it catches platform specific exceptions and re-throw them as one of the Spring’s 
    unified unchecked exception i.e. DataAccessException .

##10. How many annotations we can use to inject the bean?
####Answer:
    1)@Autowired(By type -> by name): It works on constructors, methods, method arguments, class fields, and annotations.  When the Springboot 
    application starts up, the Spring container automatically loads an org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor 
    processor. When the container scans for the @Autowired annotation, the corresponding type of Bean is found in the IoC container and injected. 
    The requird property of the @Autowired annotation means that when you use the @Autowired annotation, you should query the corresponding 
    type of bean in the container firstly.
    1.If the number of query results is exactly one in Bean, it is injected automatically
    2.If the query results in more than one in Bean, specify the name of the auto-assembled Bean through the @Qualifier annotation
    3.If no Bean of the type is queried, an exception will be thrown as the default @Autowired(required=true), the workaround is to use @Autoiwired(quired=false)
    
    2)@Resource(By name -> by type): It has two important attributes: name and type, and Spring resolves the name attribute of the @Resource 
    annotation to the bean's name and the type attribute to the bean's type. So if the name attribute is used, the byName auto-injection policy is used, 
    and the byType auto-injection policy is used when the type attribute is used. If neither name nor type attribute is specified, the policy is 
    automatically injected using byName through the reflection mechanism.
    @Resource assembly sequence:
    1.If both name and type are specified, a unique matching bean is found from the Spring context for assembly, and an exception is thrown if it is not found. 
    2.If name is specified, the assembly looks for a bean with a matching name (id) from the context and throws an exception if it is not found;
    3.If type is specified, the assembly is done by finding a unique bean with a matching type in the context; if no bean is found, or more than one bean is found, an exception is thrown;
    4.If neither name nor type is specified, the assembly is automatically carried out in byName mode. If no match is found, it is reverted to an original 
    type for matching. If yes, it is automatically assembled.
    
    3)@Inject: It is similar to @Autowired and can completely replace @Autowired, but this one has no required attribute and requires that the bean must exist.
    If you want to assemble by name, you need to use it in conjunction with another javax annotation N("name").


##11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?
####Answer:
    1)Construct Injection: The dependent objects are injected at class initialization stage. If the class has only one constructor, 
    then the @Autowired annotation can be omitted. While if you have multiple constructors in a class,  @Autowired is required 
    to specify exactly which constructor to use.
```
@Autowired
public ConstructInjectionExample(Filter filter){
    this.filter = filter;
}
```
    2)Setter Injection
```
@Autowired
public void setFilter(Filter filter){
    this.filter = filter;
}
```
    3)Field Injection
```
@Autowired
private Filed field;
```
    4)Comparison: The Construct Injection is best. With constructing method injection, you can ensure that the injected 
    component is immutable and that the required dependencies are not empty. In addition, constructor injected dependencies 
    always guarantee a fully initialized state when returned to client (component) code. In conclusion, there are three main reasons:
    1.Dependency immutability: Injecting a dependency through a constructor means injecting the dependency when the object is created.
    Once the object is created, the injected dependency can only be used and cannot be modified later. This is called dependency 
    immutability (injecting by a set method can also be modified by a set method in the future).
    2.Dependency not empty: When injected through the constructor, the injected object is automatically checked to see if it is empty. 
    If it is empty, the injection fails. The injection succeeds only if it is not empty.
    3.Completely initialized: Since the dependent object is obtained (after the initialization) and the constructor to be initialized is called,
    the final object is fully initialized.

##12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primary.
####Answer:
    1)We can use annotations @Primary.
```
@Primary
@Component("first")
public class First{

}

```
    2)If there is no primary, we can use @Qualifier annotation to specify which class we are injecting to prevent 
    throwing "not unique beans" exceptions. (Note: If both are present, the @Qualifier annotation has priority than @Primary)
    And we can also use both type and name to specify the unique bean to be injected. 

##13. What is the difference between BeanFactory and ApplicationContext in Spring?
####Answer:
    1)BeanFactory: As the lowest level interface in Spring, it contains the definition of various beans, reads bean configuration documents,
    manages the loading and instantiation of beans, controls the life cycle of beans, and maintains dependencies between beans.
    And the ApplicationContext interface, as a derivative of BeanFactory, provides more complete framework functionality in addition to the 
    functionality of BeanFactory which includes Inheriting MessageSource and therefore supports internationalization, unified access to 
    resource files, providing the event to register the bean in the listener, loading multiple configuration files at the same time, and 
    loading multiple (inherited) contexts so that each context is focused on a specific level, such as the application's web layer.
    2)BeanFactroy uses lazy loading to inject beans, meaning that a Bean is not loaded instantiated until it is used (getBean() is called).
    In this way, we can't find some existing Spring configuration problems. If one of the Bean's properties is not injected, BeanFacotry loads 
    and does not throw an exception until the first use calls the getBean method. While ApplicationContext creates all beans at once when the container starts. 
    This way, when the container starts, we can find configuration errors in Spring, which is helpful to check if the dependent properties are injected. 
    The ApplicationContext preloads all of its single-instance beans when it starts. By preloading single-instance beans, you ensure that when you need them,
    you don't have to wait because they are already created. Compared with the basic BeanFactory, the only disadvantage of the ApplicationContext 
    is that it occupies memory space. When the application has a large number of beans configured, the program starts slowly.
    3)The BeanFactory is usually created programmatically, while the ApplicationContext can also be created declaratively, such as using ContextLoader.
    4)Both BeanFactory and ApplicationContext support the use of BeanPostProcessor and BeanFactoryPostProcessor, but the differences 
    between them are as follows: the BeanFactory requires manual registration, while the ApplicationContext registers automatically.

##14. What is the Scope of a Bean? and list the examples for each scope.
####Answer:
    1)Basic: Singleton
    This scopes the bean definition to a single instance per Spring IoC
    container (default). The object is created between container startup and the completion of the singleton. Each bean is 
    singleton while the spring container runs the process.
```
@Service
@Scope(value=ConfigurableBeanFactory.SCOPE_SINGLETON)
public class CustomerService{

}
```
    2)Basic: Prototype
    This scopes a single bean definition to have any number of object instances.
    Multiple instances do not create objects when the container starts. They are created when the bean object is fetched, and each time it is fetched, 
    a new object is obtained.
```
@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personProtoType(){
    return new Person();
}

```
    3)for Web application:
    1.Request: This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.
    2.Session: This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext
    3.Application: A bean definition corresponds to the lifecycle of a single ServletContext. This scope applies only to the 
    WebApplicationContext environment.
    4.Websocket: A bean definition corresponds to the life cycle of a single websocket. This scope applies only to the WebApplicationContext environment.
```
@RequestScope
@Component
public class loginAction{

}

@Bean
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public HelloMessageGenerator requestScopedBean() {
    return new HelloMessageGenerator();
}
```

##15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml)
####Answer:
    in XML file using constructor injection:
```
<bean id = "userid" class = "com.test.spring.ioc.dependency.injection.UserHolder">
    <constructor-arg name="user" ref="superUser"/>
</bean>

```
    in XML file using setter injection:
```
<bean id = "userid" class = "com.test.spring.ioc.dependency.injection.UserHolder">
    <property name="user" ref="superUser"/>
</bean>

```
    in main process:
```
public static void main(String[] args) {
    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);    
    //it is under resources folder, where we save the XML configuration for the class
    String xmlResourcePath = "classpath:/dependency-setter-injection.xml";      
    beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);      
    UserHolder userHolder = beanFactory.getBean(UserHolder.class);
    System.out.println(userHolder);
}
```



    

