# Homework 10

### 1. List all of the annotations you learned from class and homework to annotaitons.md

### 2. Type the Comment feature for the class project

### 3. In postman, call of the APIs in PostController and CommentController

### 4. what is JPA? and what is Hibernate?
JPA stands for Java Persistence API. It is a specification which gives a standard API for accessing databases within java applications. As JPA is just a specification, it does not perform any operation by itself. It requires an implementation, there are many JPA implementations available like Hibernate, iBatis, TopLink, EclipseLink etc. Hibernate ORM is the most popular implementation of JPA.

Hibernate is an Object Relational Mapping tool (ORM tool), that maps the Java objects to the database tables and vice-versa.

### 5. What is Hiraki? what is the benefits of connection pool?
Hikari is a popular and high-performance JDBC (Java Database Connectivity) connection pooling library for Java applications. It provides a fast, efficient, and reliable way to manage database connections in a Java application.

Regarding the benefits of a connection pool, a connection pool is a cache of database connections maintained so the connections can be reused when new requests to the database are required. Some of the benefits of using a connection pool include:

1, Improved performance: By reusing existing connections, a connection pool can reduce the overhead of creating a new connection for each database request, which can greatly improve the overall performance of your application.
2, Increased scalability: Connection pools can handle a large number of database connections and can scale to accommodate growing numbers of database requests.
3, Reduced resource overhead: Connection pools can reduce the resource overhead of maintaining many open database connections, as only a limited number of connections are created and maintained in the pool.
4, Improved reliability: Connection pools can provide improved reliability by detecting and recovering from failed database connections and ensuring that connections are returned to the pool once they are no longer in use.
5, Improved security: Connection pools can also provide additional security features, such as connection password encryption and protection against SQL injection attacks.

Hikari specifically provides a number of benefits compared to other connection pooling libraries, including: high performance, low overhead, and automatic tuning for optimal performance. Additionally, it has a simple and easy-to-use configuration and is well documented, making it a popular choice for Java developers.

### 6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.

### 7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?
The cascade and orphanRemoval attributes are used in JPA entity relationships to specify the behavior of the relationship when the related entities are persisted, updated, or deleted.

The cascade attribute is used to specify the operations that should be cascaded from the source entity to the target entity. For example, if cascade = CascadeType.ALL, any operations performed on the source entity will be automatically cascaded to the target entity. The CascadeType.ALL setting specifies that all operations (PERSIST, MERGE, REMOVE, REFRESH, and DETACH) should be cascaded.

The orphanRemoval attribute is used to specify whether or not entities that are no longer referenced by the source entity should be removed from the database. If orphanRemoval = true, any entities in the relationship that are no longer referenced by the source entity will be automatically removed from the database.

the javax.persistence.CascadeType enum contains: 
ALL
PERSIST
MERGE
REMOVE
REFRESH
DETACH

### 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
Sometimes you have two entities and there's a relationship between them. Eager Loading is a design pattern in which data initialization occurs on the spot.
Lazy Loading is a design pattern that we use to defer initialization of an object as long as it's possible.
In eager loading strategy, if we load one entity data, it will also load up all related data of the other entity associated with it and will store it in a memory.
But when we enable lazy loading, if we pull up one entity data lazily, the other entity's data won't be initialized and loaded into a memory until we make an explicit call to it.

### 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples? 
JPA repository method naming conventions are conventions for naming the methods in a JPA repository interface. These conventions are used by the JPA implementation (such as Hibernate) to automatically generate the appropriate SQL queries for the methods defined in the repository.

The rules of JPA repository method naming conventions are based on the Spring Data project, which provides a set of standard naming conventions for common data access operations. Some of the most commonly used naming conventions are:

Find by ID: To find an entity by its primary key, you can use the findById method, which is automatically generated by the JPA implementation.
Find All: To find all entities of a given type, you can use the findAll method, which is automatically generated by the JPA implementation.
Find by attribute: To find entities by a specific attribute, you can use the findByAttribute method, where Attribute is the name of the attribute you want to search by. For example, findByLastName to find all entities with a specific last name.
Count: To count the number of entities of a given type, you can use the count method, which is automatically generated by the JPA implementation.

Note that you do not need to implement the methods yourself, as the JPA implementation (such as Hibernate) will automatically generate the appropriate SQL queries for the methods defined in the repository based on the naming conventions.

### 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.

### 11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-redbook/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate.

### 12. (Optional) use JDBC to read the data from database.

## Part2

### 1. List all of the annotations you learned from class and homework to annotaitons.md

### 2. type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.

### 3. What is JPQL?
JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax. But it won’t affect the database directly.

JPQL can retrieve information or data using SELECT clause, can do bulk updates using UPDATE clause and DELETE clause. EntityManager.createQuery() API will support for querying language.


### 4. What is @NamedQuery and @NamedQueries?
In simple terms, a named query is a query that can be identified by a name. You could define a named query as below and use it by its name.

```java
@NamedQuery name="findAllUsers" query="SELECT u FROM Users u"
findByNamedQuery("findAllUsers")
```

Attaching multiple named queries to the same entity class requires wrapping them in a @NamedQueries annotation: 
```java
@Entity

@NamedQueries({
    @NamedQuery(name="Country.findAll",
                query="SELECT c FROM Country c"),
    @NamedQuery(name="Country.findByName",
                query="SELECT c FROM Country c WHERE c.name = :name"),
}) 
public class Country {
  ...
}
```


### 5. What is @Query? In which Interface we write the sql or JPQL?
In order to define SQL to execute for a Spring Data repository method, we can annotate the method with the @Query annotation — its value attribute contains the JPQL or SQL to execute.

The @Query annotation takes precedence over named queries, which are annotated with @NamedQuery or defined in an orm.xml file.

### 6. What is HQL and Criteria Queries?
HQL is to perform both select and non-select operations on the data, but Criteria is only for selecting the data, we cannot perform non-select operations using criteria.

HQL is suitable for executing Static Queries, where as Criteria is suitable for executing Dynamic Queries.

HQL doesn’t support pagination concept, but we can achieve pagination with Criteria.

Criteria used to take more time to execute then HQL.

With Criteria we are safe with SQL Injection because of its dynamic query generation but in HQL as your queries are either fixed or parametrized, there is no safe from SQL Injection.

### 7. What is EnityManager?
The EntityManager API is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities.

### 8. What is SessionFactory and Session?
SessionFactory is a factory class for Session objects. It is available for the whole application while a Session is only available for particular transaction.

Session is short-lived while SessionFactory objects are long-lived. SessionFactory provides a second level cache and Session provides a first level cache.

### 9. What is Transaction? how to manage your transaction?
A database transaction is a sequence of actions that are treated as a single unit of work. These actions should either complete entirely or take no effect at all.

### 10. What is hibernate Caching?
Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database. It is very useful when you need to fetch the same kind of data multiple times.

### 11. What is the difference between first-level cache and second-level cache?
he First level cache is by default enabled by Hibernate itself. The session object maintains the first-level cache.

An application can have many sessions. Data hold by one session object is not accessible to the entire application — means the data of a particular session is not shared with other sessions of the application. So you can use the first-level cache to store local data i.e. required by the session itself.

When you query an entity or object, for the very first time it is retrieved from the database and stored into the first-level cache (associated with the hibernate session). If we query for the same entity or object again with the same session object, it will be loaded from cache and no SQL query will be executed.

The second-level cache is by default disabled, the developer needs to enable it explicitly, and the SessionFactory object is responsible to maintain it. The second-level cache is accessible by the entire application means data hold by SessionFactory can be accessible to all the sessions. Keep in mind that, once the session factory is closed all the cache associated with that is also removed from the memory.

When hibernate session try to load an entity, it will first find into the first-level cache, if it does not found then it will look into the second-level cache and return the response (if available), but before returning the response it will store that object/data into first-level also so next time no need to come at the session-level. When data is not found in the second level then it will go to the database to fetch data. Before returning a response to the user it will store that object/data into both levels of cache so next time it will be available at cache stages only.

### 12. How do you understand @Transactional?
The @Transactional annotation is the metadata that specifies the semantics of the transactions on a method. 

### 13. Write a simple factory design pattern.