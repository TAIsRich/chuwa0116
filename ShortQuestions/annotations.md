#@Override
类或接口继承时用于标记重写的方法
```java
class fruit{
    public class eat{
        System.out.println("eat fruit");
    }
}
class apple extends fruit{
    @Override
    public class eat{
        System.out.println("eat apple");
    }
}
```
#@Deprecated
标记过时的元素
```java
public class Hero {
    @Deprecated
    public void say(){
        Log.d("Hero","I have nothing to say");
    }
    
}
```
#@Test
标记test接口，用于测试
```java
public class MyMathTest {

    @Test
    public void add() {
    }
}
```
#@Service
在service层前
```java
@Service
public class service{
    
}
```
#@Component
组件，没有明确的角色,用于把当前类对象存入Spring容器中。

#@Controller
用于cotrller层前。
```java
@Controller
public class controller{
    
}
```
#@Repository
用在DAO层
```java
@Repository
public class DAO{
    
}
```
#@RestController
是@ResponseBody和@Controller的组合注解。可以返回json
```java
@RestController
public class HelloController {

    @RequestMapping(value="/hello",method= RequestMethod.GET)
    public String sayHello(){
        return "hello";
    }
}
```
#@RequestMapping
配置url映射，作用在控制器的某个方法上，也可以作用在此控制器类上。
```java
@Controller
@RequestMapping("/hello")
public class HelloController {

    @RequestMapping(method= RequestMethod.GET)
    public String sayHello(){
        return "hello";
    }
}
```
#@Autowired
可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作，@Autowired标注可以放在成员变量上，也可以放在成员变量的set方法上，也可以放在任意方法上表示，自动执行当前方法，如果方法有参数，会在IOC容器中自动寻找同类型参数为其传值。
```java
public class MovieRecommender {
 
    private final CustomerPreferenceDao customerPreferenceDao;
 
    @Autowired
    private MovieCatalog movieCatalog;
 
    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }
 
    // ...
}
```
#@PostMapping    
@PostMapping是@RequestMapping注解的专用版本，用作@RequestMapping(method = RequestMethod.POST)的快捷方式。 @PostMapping带注解的方法处理与给定 URI 表达式匹配的 HTTP POST请求。
```java
@PostMapping(path = "/members", consumes = "application/json", produces = "application/json")
public void addMember(@RequestBody Member member) {
	//code
}
```
#@GetMapping
@GetMapping是@RequestMapping注解的专用版本，用作@RequestMapping(method = RequestMethod.GET)的快捷方式。 @GetMapping带注解的方法处理与给定 URI 表达式匹配的 HTTP GET请求。
```java
@GetMapping("/members/{id}")
public String getMembers(Model model) {
	return "member";
}
```
#@PutMapping
同上，处理Put请求
```java
@PutMapping()
public void putMemebers(@RequestBody Model model){
    //code
}
```
#@DeleteMapping
同上，处理Delete请求
```java
@DeleteMapping()
public void deleteMemebers(@RequestBody Model model){
    //code
}
```

#@GeneratedValue
The annotation can be used to indicate that the values for the annotated field should be automatically generated by the database when a new entity is persisted. The generation strategy can be specified using the "strategy" attribute of the annotation. Common generation strategies include AUTO, SEQUENCE, IDENTITY, and TABLE.
```java
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    //...
}
```
#@JsonProperty
used to specify the name of a property in the JSON representation of an object.
```java
public class User {
    private String firstName;
    private String lastName;

    @JsonProperty("first_name")
    public String getFirstName() {
        return firstName;
    }
}
```

#@CreationTimestamp
It is used to automatically populate a field with the current timestamp when a new entity is persisted to the database for the first time.

```java
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    private String name;
    private LocalDateTime createdAt;

    @CreationTimestamp
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    //...
}

```

#@UpdateTimestamp
Similar with CreationTimestamp. It is used to automatically update a field with the current timestamp whenever an entity is updated and persisted to the database.

#@RequestBody
It is used to bind the request body of an HTTP request to a method parameter in a Spring MVC controller.
```java
@RestController
public class UserController {
    @PostMapping("/users")
    public ResponseEntity<Void> createUser(@RequestBody User user) {
        // save the user and return a response
        //...
    }
}
```

#@PathVariable
It is used to bind a method parameter to a URI template variable in a Spring MVC controller.
```java
@RestController
public class UserController {
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        // retrieve the user with the specified id and return it
        //...
    }
}

```
#@Configuration
It is an annotation that indicates that a class declares one or more. It is used to indicate that a class is a configuration class.
```java
//Example with @Bean
```
#@Bean
@Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports most of the attributes offered by <bean/> , such as: init-method , destroy-method , autowiring , lazy-init , dependency-check , depends-on and scope.
```java
@Configuration
public class AppConfig {
   @Bean
   public MyService myService() {
      return new MyServiceImpl();
   }
}
```

#@ExceptionHandler

```java
@ControllerAdvice
public class ExceptionHandlerController {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse("500", ex.getMessage());
        return new ResponseEntity<ErrorResponse>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

# @CompnonentScan
@ComponentScan is an annotation in Spring that is used to enable component scanning in your application. Component scanning is a process that Spring uses to automatically detect and register Spring components (such as @Component, @Service, @Repository, and @Controller) in your application.
```java
@SpringBootApplication
@ComponentScan("com.example.myapp")
public class MyAppApplication {
    // ...
}
```

# @SpringBootApplication
@SpringBootApplication is a convenience annotation that combines three other annotations commonly used in Spring Boot applications: @Configuration, @EnableAutoConfiguration, and @ComponentScan. It is typically used to annotate the main class of a Spring Boot application, as it enables auto-configuration and component scanning for the application.  
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

# @Aspect
@Aspect is a Spring Framework annotation used to declare a class as an aspect. An aspect is a module that encapsulates cross-cutting concerns, which are separate from the application's main business logic. The @Aspect annotation is used along with other annotations like @Before, @After, @Around, @AfterReturning, and @AfterThrowing to define the behavior of the aspect in response to method calls or specific events in the application.

```java
@Aspect
@Component
public class LoggingAspect {
 
    @Before("execution(* com.example.myapp.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Executing method: " + joinPoint.getSignature().getName());
    }
 
    @AfterReturning(pointcut = "execution(* com.example.myapp.service.*.*(..))",
                    returning= "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        System.out.println("Executed method: " + joinPoint.getSignature().getName() + ", Result: " + result);
    }
 
    @AfterThrowing(pointcut = "execution(* com.example.myapp.service.*.*(..))",
                   throwing = "error")
    public void logAfterThrowing(JoinPoint joinPoint, Throwable error) {
        System.out.println("Error in method: " + joinPoint.getSignature().getName() + ", Message: " + error.getMessage());
    }
}
```

# @EnableScheduling
It is used in conjunction with @Scheduled annotation, which is used to specify when a task should be executed.
```java
@SpringBootApplication
@EnableScheduling
public class MyApplication {

   public static void main(String[] args) {
      SpringApplication.run(MyApplication.class, args);
   }

   @Scheduled(fixedDelay = 1000)
   public void myScheduledTask() {
      System.out.println("Executing scheduled task...");
   }

}
```

# @BeforeAll
It is a JUnit annotation that is used to indicate that a method should be executed once before all test methods in a test class. This annotation can be used on static methods, and is typically used to perform setup tasks that only need to be done once for all tests in the class.
```java
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MyTest {

    private static MyClass myClass;

    @BeforeAll
    public static void setup() {
        myClass = new MyClass();
    }

    @Test
    public void testMyMethod() {
        // Call the method being tested
        String result = myClass.myMethod();

        // Verify the result
        assertEquals("expected result", result);
    }
}

```
# @BeforeEach
It is a JUnit annotation that is used to indicate that a method should be executed before each test method in a test class. This annotation can be used on instance or static methods, and is typically used to perform setup tasks that need to be done before each test in the class.  
```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MyTest {

    private MyClass myClass;

    @BeforeEach
    public void setup() {
        myClass = new MyClass();
    }

    @Test
    public void testMyMethod() {
        // Call the method being tested
        String result = myClass.myMethod();

        // Verify the result
        assertEquals("expected result", result);
    }

    @Test
    public void testAnotherMethod() {
        // Call another method being tested
        int result = myClass.anotherMethod();

        // Verify the result
        assertEquals(42, result);
    }
}
```

# @AfterAll
It is a JUnit annotation that is used to indicate that a method should be executed once after all test methods in a test class have been run. This annotation can be used on static methods, and is typically used to perform cleanup tasks that only need to be done once after all tests in the class.
```java
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MyTest {

    @Test
    public void testMyMethod() {
        // Call the method being tested
        String result = MyClass.myMethod();

        // Verify the result
        assertEquals("expected result", result);
    }

    @AfterAll
    public static void cleanup() {
        // Perform cleanup tasks here
    }
}
```

# @AfterEach
It is a JUnit annotation that is used to indicate that a method should be executed after each test method in a test class. This annotation can be used on instance or static methods, and is typically used to perform cleanup tasks that need to be done after each test in the class.
```java
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MyTest {

    private MyClass myClass;

    @BeforeEach
    public void setup() {
        myClass = new MyClass();
    }

    @Test
    public void testMyMethod() {
        // Call the method being tested
        String result = myClass.myMethod();

        // Verify the result
        assertEquals("expected result", result);
    }

    @Test
    public void testAnotherMethod() {
        // Call another method being tested
        int result = myClass.anotherMethod();

        // Verify the result
        assertEquals(42, result);
    }

    @AfterEach
    public void cleanup() {
        // Perform cleanup tasks here
    }
}
```

# @@Mock and @InjectMocks
@Mock is used to create a mock object of a class or interface. A mock object is a fake implementation of an interface or class, which is used to simulate the behavior of real objects in a controlled way. Mock objects are useful for testing because they allow you to isolate the code being tested and verify that it is behaving as expected without the need for real dependencies.

@InjectMocks is used to inject the mocks created with @Mock into the object being tested. The object being tested is typically an instance of a class, and @InjectMocks injects the mock objects into the class, replacing any real dependencies. This allows you to test the behavior of the class in isolation, without the need for real dependencies.
```java
@RunWith(MockitoJUnitRunner.class)
public class MyTest {

    @Mock
    private Dependency dependency;

    @InjectMocks
    private MyClass myClass;

    @Test
    public void testMyMethod() {
        // Setup expectations on the dependency
        when(dependency.doSomething()).thenReturn("mock result");

        // Call the method being tested
        String result = myClass.myMethod();

        // Verify the result
        assertEquals("mock result", result);
    }
}
```

# @Spy
It is a Mockito annotation that is used to create a real instance of a class and spy on it. This means that the real methods of the class will be called, but their behavior can be modified using Mockito's mocking capabilities.
```java
import org.junit.jupiter.api.Test;
import org.mockito.Spy;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class MyTest {

    @Spy
    private MyClass myClass;

    @Test
    public void testMyMethod() {
        // Set up the spy to return a specific value
        when(myClass.myMethod()).thenReturn("expected result");

        // Call the method being tested
        String result = myClass.myMethod();

        // Verify the result
        assertEquals("expected result", result);

        // Verify that the real method was called
        verify(myClass).myMethod();
    }
}

```