# HW 42

 ### 1 List all of the annotations you learned from class and homework to annotaitons.md

### 2 Type the Comment feature for the class project.

### 3 In postman, call of the APIs in PostController and CommentController

### 4 What is JPA? and what is Hibernate?

As a specification, the Jakarta Persistence API(formerly Java Persistence API) is concerned with *persistence*, which loosely means any mechanism by which Java objects outlive the application process that created them. Not all Java objects need to be persisted, but most applications persist key business objects. The JPA specification lets you define *which* objects should be persisted, and *how* they are persisted in your Java applications.

JPA use JDBC to CRUD database, and also transfer result from database to Java Entities.

Hibernate is a Java framework that simplifies the development of Java application to interact with the database. It is an open source, lightweight, ORM (Object Relational Mapping) tool. Hibernate implements the specifications of JPA (Java Persistence API) for data persistence.

### 5 What is Hiraki? what is the benefits of connection pool?

Hikari Connection Pool commonly referred to as HikariCP is a very fast light weight Java connection pool.

A connection pool is a cache of database connections. A Connection Pool maintains connections that can be reused when future requests to the database are required. 

### 6 What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.

+ `@OneToMany` one-to-many mapping means that one row in a table is mapped to multiple rows in another table.

  ```java
  @Entity
  public class Person {
      @Id
      @GeneratedValue(strategy = GenerationType.AUTO)
      private int id;
      private String name;
      @OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
      private List<Address> addresses;
  }
  ```

+ `@ManyToOne` multiple rows in the table is mapped to one row in another table.

  ```java
  @Entity
  public class Student {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;
    private String name;
  
    @ManyToOne(cascade=CascadeType.MERGE)
    private Department department;
  }
  ```

  

+ `@ManyToMany` A relationship is a connection between two types of entities. In the case of a many-to-many relationship, both sides can relate to multiple instances of the other side.

  ```java
  @Entity
  class Student {
  
      @Id
      Long id;
  
      @ManyToMany
      Set<Course> likedCourses;
  
      // additional properties
      // standard constructors, getters, and setters
  }
  
  @Entity
  class Course {
  
      @Id
      Long id;
  
      @ManyToMany
      Set<Student> likes;
  
      // additional properties
      // standard constructors, getters, and setters
  }
  ```

### 7 What is the `cascade = CascadeType.ALL`, `orphanRemoval = true`? and what are the other CascadeType and their features? In which situation we choose which one?

+ `CascadeType.ALL` all cascade operations on owning entity applied to related entity
+ `CascadeType.PERSIST` owing entity saved -> related entity saved
+ `CascadeType.MERGE` owing entity merged -> related entity merged
+ `CascadeType.REFRESH` owing entity refreshed -> related entity refreshed
+ `CascadeType.REMOVE` owing entity removed -> related entity removed
+ `CascadeType.DETACH` owing entity manually detached -> related entity detached

`orphanRemoval` is an entirely ORM-specific thing. It marks "child" entity to be removed when it's no longer referenced from the "parent" entity, e.g. when you remove the child entity from the corresponding collection of the parent entity.

When we remove the relationship between a parent and child, the child record becomes an orphan record meaning that it does not have a parent record. Consider the example of tournament and registration tables where a player withdraws from a tournament. The registration gets removed from the tournament entity. The registration record becomes an orphan record. Orphan records mean that the database is in an inconsistent state.

### 8 What is the `fetch = FetchType.LAZY`, `fetch = FetchType.EAGER`? what is the difference? In which situation you choose which one?

There are two ways in which data is loaded: eager and lazy. Eager fetch means that when a record is fetched from the database, all the associated records from related tables are also fetched. So if we fetch a tournament record, all the registrations for the tournament are also fetched.
Eager fetch is the default fetch type used by Hibernate but it is not always the most efficient. Lazy fetch on the other hand, fetches the records only when they are needed.

+ `FetchType.Lazy `
  + If we don't need data from comment, JPA doesn't fetch it
  + Onyly fetch data from post 
  + when we need data from comment, then JPA fecth comment data
+ `FetchType.Eager`
  + when we fetch post, JPA also fetch comment at the same time.

### 9 What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

Spring data JPA has its own naming conventions for methods. Following these conventions we can build sophisticated queries. These conventions are called also called as method name strategies. These strategies have defined set of keyword to use in method names. Based on the formed method name, method performs predefined operations. 

We don't need to implement the method.

```java
findByTitle(String title);
findByAgeIsNull();
findByAgeGreaterThan();
```

### 10 Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.

### 1 List all of the annotations you learned from class and homework to annotaitons.md

### 2 type the code, you need to checkout new branch from branch 02_post_RUD

### 3 What is JPQL?

JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax. But it won’t affect the database directly.

JPQL can retrieve information or data using SELECT clause, can do bulk updates using UPDATE clause and DELETE clause. EntityManager.createQuery() API will support for querying language.

### 4 What is @NamedQuery and @NamedQueries?

`@NameQueries` annotation is used to define the multiple named queries.

`@NameQuery` annotation is used to define the single named query.

### 5 What is @Query? In which Interface we write the sql or JPQL?

`@Query` defines a query that we can execute.

Repository interface.

### 6 What is HQL and Criteria Queries?

Hibernate Query Language (HQL) is an object-oriented query language, similar to SQL, but instead of operating on tables and columns, HQL works with persistent objects and their properties. HQL queries are translated by Hibernate into conventional SQL queries, which in turns perform action on database.

It enables us to write queries without doing raw SQL as well as gives us some object-oriented control over the queries, which is one of the main features of Hibernate. The Criteria API allows us to build up a criteria query object programmatically, where we can apply different kinds of filtration rules and logical conditions.

### 7 What is EnityManager?

A JPA EntityManager manages connection to a database as well as to database operations.  EntityManager is associated with a  PersistenceContext. All operations that are performed in a specific session are stored inside the PersistenceContext. EntityManager is the interface to the  Persistence Context. All operations on the entity go through the  EntityManager. We will declare an  EntityManager object in our class and mark it with the @PersistenceContext annotation.

### 8 What is SessionFactory and Session?

SessionFactory is an interface. SessionFactory can be created by providing Configuration object, which will contain all DB related property details pulled from either hibernate.cfg.xml file or hibernate.properties file. SessionFactory is a factory for Session objects.

A Session is used to get a physical connection with a database. The Session object is lightweight and designed to be instantiated each time an interaction is needed with the database. Persistent objects are saved and retrieved through a Session object.

### 9 What is Transaction? how to manage your transaction?

A transaction simply represents a unit of work. In such case, if one step fails, the whole transaction fails (which is termed as atomicity). A transaction can be described by ACID properties (Atomicity, Consistency, Isolation and Durability).

Commit or roll back.

### 10 What is hibernate Caching?

Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database. It is very useful when you need to fetch the same kind of data multiple times.

### 11  What is the difference between first-level cache and second-level cache?

| Sr. No. |      Key      |                      First level cache                       |                      Second level cache                      |
| ------- | :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 1       |     Basic     | First level cache is a session level cache and it is always associated with session level object | Second level cache is session factory level cache and it is available across all sessions |
| 2       |    Enabled    |                  It is enabled by default.                   |                It is not enabled by default.                 |
| 3       | Availability  |                It is available for a session                 |             It is available across all session.              |
| 4       | Configuration |               No Extra configuration required                | We have to decide which concurrency strategy to use and also need to configure cache expiration and physical cache attributes. |

### 12 How do you understand @Transactional?

### 13 Write a simple factory design pattern.

```java
public abstract class Fruit {
  public abstract String getName();
}
```

```java
public class Banana extends Fruit {
  public String getName() {
    return "Banana";
  }
}
```

```java
public class Apple extends Fruit {
  public String getName() {
    return "Apple";
  }
}
```

```java
public class FruitFactory {
  public Fruit createFruit(String type) {
    Fruit fruit = null;
    if ("banana".equals(type)) {
      fruit = new Banana();
    } else if ("apple".equals(type)) {
      fruit = new Apple();
    } else {
      throw new RuntimeException("No such type!");
    }
    return fruit;
  }
}
```

```java
public class Client {
  public static void main(String[] args) {
    FruitFactory ff = new FruitFactory();
    Fruit druit = ff.createFruit("apple");

    System.out.println(fruit.getName());
  }
}
```

